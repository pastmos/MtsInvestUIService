// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: security.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Iticapital_ApiMts_Security_V1_TradingStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unspecified // = 0
  case unavailableForTrading // = 1
  case openingPeriod // = 2
  case closingPeriod // = 3
  case trading // = 4
  case halt // = 5
  case tradingClosed // = 6
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .unavailableForTrading
    case 2: self = .openingPeriod
    case 3: self = .closingPeriod
    case 4: self = .trading
    case 5: self = .halt
    case 6: self = .tradingClosed
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .unavailableForTrading: return 1
    case .openingPeriod: return 2
    case .closingPeriod: return 3
    case .trading: return 4
    case .halt: return 5
    case .tradingClosed: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Iticapital_ApiMts_Security_V1_TradingStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Iticapital_ApiMts_Security_V1_TradingStatus] = [
    .unspecified,
    .unavailableForTrading,
    .openingPeriod,
    .closingPeriod,
    .trading,
    .halt,
    .tradingClosed,
  ]
}

#endif  // swift(>=4.2)

enum Iticapital_ApiMts_Security_V1_SecurityType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unspecified // = 0
  case futures // = 1
  case options // = 2

  ///Акции обыкновенные
  case stock // = 3

  ///Акции привилегированные
  case stockPreference // = 4

  ///Государственные облигации
  case bondGovernment // = 5

  ///Региональные облигации
  case bondRegional // = 6

  ///Облигации центральных банков
  case bondCb // = 7

  ///Корпоративные облигации
  case bondCorporate // = 8

  ///Облигации МФО
  case bondMfo // = 9

  ///Биржевые облигации
  case bondExchange // = 10

  ///Муниципальные облигации
  case bondMunicipal // = 11

  ///mutual investment fund паевой инвестиционный фонд
  case mifOpen // = 12

  ///Паи интервальных ПИФов
  case mifInterval // = 13

  ///Паи закрытых ПИФов
  case mifClosed // = 14

  ///Паи биржевых ПИФов
  case mifExchange // = 15

  ///Депозитарные расписки
  case depositaryReceipts // = 16
  case index // = 17
  case currency // = 18
  case rtsStandard // = 19

  ///Драгоценный металл
  case ore // = 20

  ///Ипотечный сертификат
  case mortgageSertificate // = 21

  ///Корзина бумаг
  case etf // = 22
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .futures
    case 2: self = .options
    case 3: self = .stock
    case 4: self = .stockPreference
    case 5: self = .bondGovernment
    case 6: self = .bondRegional
    case 7: self = .bondCb
    case 8: self = .bondCorporate
    case 9: self = .bondMfo
    case 10: self = .bondExchange
    case 11: self = .bondMunicipal
    case 12: self = .mifOpen
    case 13: self = .mifInterval
    case 14: self = .mifClosed
    case 15: self = .mifExchange
    case 16: self = .depositaryReceipts
    case 17: self = .index
    case 18: self = .currency
    case 19: self = .rtsStandard
    case 20: self = .ore
    case 21: self = .mortgageSertificate
    case 22: self = .etf
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .futures: return 1
    case .options: return 2
    case .stock: return 3
    case .stockPreference: return 4
    case .bondGovernment: return 5
    case .bondRegional: return 6
    case .bondCb: return 7
    case .bondCorporate: return 8
    case .bondMfo: return 9
    case .bondExchange: return 10
    case .bondMunicipal: return 11
    case .mifOpen: return 12
    case .mifInterval: return 13
    case .mifClosed: return 14
    case .mifExchange: return 15
    case .depositaryReceipts: return 16
    case .index: return 17
    case .currency: return 18
    case .rtsStandard: return 19
    case .ore: return 20
    case .mortgageSertificate: return 21
    case .etf: return 22
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Iticapital_ApiMts_Security_V1_SecurityType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Iticapital_ApiMts_Security_V1_SecurityType] = [
    .unspecified,
    .futures,
    .options,
    .stock,
    .stockPreference,
    .bondGovernment,
    .bondRegional,
    .bondCb,
    .bondCorporate,
    .bondMfo,
    .bondExchange,
    .bondMunicipal,
    .mifOpen,
    .mifInterval,
    .mifClosed,
    .mifExchange,
    .depositaryReceipts,
    .index,
    .currency,
    .rtsStandard,
    .ore,
    .mortgageSertificate,
    .etf,
  ]
}

#endif  // swift(>=4.2)

enum Iticapital_ApiMts_Security_V1_Currency: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unspecified // = 0
  case rub // = 1
  case usd // = 2
  case eur // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .rub
    case 2: self = .usd
    case 3: self = .eur
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .rub: return 1
    case .usd: return 2
    case .eur: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Iticapital_ApiMts_Security_V1_Currency: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Iticapital_ApiMts_Security_V1_Currency] = [
    .unspecified,
    .rub,
    .usd,
    .eur,
  ]
}

#endif  // swift(>=4.2)

struct Iticapital_ApiMts_Security_V1_ListSecuritiesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Iticapital_ApiMts_Security_V1_ListSecuritiesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: Google_Rpc_Status {
    get {return _storage._status ?? Google_Rpc_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  var securities: [Iticapital_ApiMts_Security_V1_Security] {
    get {return _storage._securities}
    set {_uniqueStorage()._securities = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Iticapital_ApiMts_Security_V1_Security {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique string name of the security - tiker.
  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  var secType: Iticapital_ApiMts_Security_V1_SecurityType {
    get {return _storage._secType}
    set {_uniqueStorage()._secType = newValue}
  }

  var lotSize: UInt32 {
    get {return _storage._lotSize}
    set {_uniqueStorage()._lotSize = newValue}
  }

  var faceValue: UInt32 {
    get {return _storage._faceValue}
    set {_uniqueStorage()._faceValue = newValue}
  }

  /// google.type.Date issue_date                    = 6; // NOT USED //
  var maturityDate: Google_Type_Date {
    get {return _storage._maturityDate ?? Google_Type_Date()}
    set {_uniqueStorage()._maturityDate = newValue}
  }
  /// Returns true if `maturityDate` has been explicitly set.
  var hasMaturityDate: Bool {return _storage._maturityDate != nil}
  /// Clears the value of `maturityDate`. Subsequent reads from it will return its default value.
  mutating func clearMaturityDate() {_uniqueStorage()._maturityDate = nil}

  /// Date of the previous trading day // Date of the last trading session
  var prevTradeDate: Google_Type_Date {
    get {return _storage._prevTradeDate ?? Google_Type_Date()}
    set {_uniqueStorage()._prevTradeDate = newValue}
  }
  /// Returns true if `prevTradeDate` has been explicitly set.
  var hasPrevTradeDate: Bool {return _storage._prevTradeDate != nil}
  /// Clears the value of `prevTradeDate`. Subsequent reads from it will return its default value.
  mutating func clearPrevTradeDate() {_uniqueStorage()._prevTradeDate = nil}

  var limitUp: SwiftProtobuf.Google_Protobuf_DoubleValue {
    get {return _storage._limitUp ?? SwiftProtobuf.Google_Protobuf_DoubleValue()}
    set {_uniqueStorage()._limitUp = newValue}
  }
  /// Returns true if `limitUp` has been explicitly set.
  var hasLimitUp: Bool {return _storage._limitUp != nil}
  /// Clears the value of `limitUp`. Subsequent reads from it will return its default value.
  mutating func clearLimitUp() {_uniqueStorage()._limitUp = nil}

  var limitDown: SwiftProtobuf.Google_Protobuf_DoubleValue {
    get {return _storage._limitDown ?? SwiftProtobuf.Google_Protobuf_DoubleValue()}
    set {_uniqueStorage()._limitDown = newValue}
  }
  /// Returns true if `limitDown` has been explicitly set.
  var hasLimitDown: Bool {return _storage._limitDown != nil}
  /// Clears the value of `limitDown`. Subsequent reads from it will return its default value.
  mutating func clearLimitDown() {_uniqueStorage()._limitDown = nil}

  /// Value of the due coupon payment, expressed in the currency of settlement
  var coupon: Iticapital_ApiMts_Type_Float {
    get {return _storage._coupon ?? Iticapital_ApiMts_Type_Float()}
    set {_uniqueStorage()._coupon = newValue}
  }
  /// Returns true if `coupon` has been explicitly set.
  var hasCoupon: Bool {return _storage._coupon != nil}
  /// Clears the value of `coupon`. Subsequent reads from it will return its default value.
  mutating func clearCoupon() {_uniqueStorage()._coupon = nil}

  /// Coupon period, in days
  var couponPeriod: UInt32 {
    get {return _storage._couponPeriod}
    set {_uniqueStorage()._couponPeriod = newValue}
  }

  /// Date of the due coupon payment
  var nextCoupon: Google_Type_Date {
    get {return _storage._nextCoupon ?? Google_Type_Date()}
    set {_uniqueStorage()._nextCoupon = newValue}
  }
  /// Returns true if `nextCoupon` has been explicitly set.
  var hasNextCoupon: Bool {return _storage._nextCoupon != nil}
  /// Clears the value of `nextCoupon`. Subsequent reads from it will return its default value.
  mutating func clearNextCoupon() {_uniqueStorage()._nextCoupon = nil}

  var currency: Iticapital_ApiMts_Security_V1_Currency {
    get {return _storage._currency}
    set {_uniqueStorage()._currency = newValue}
  }

  /// Order's minimum price step
  var minStep: Iticapital_ApiMts_Type_Float {
    get {return _storage._minStep ?? Iticapital_ApiMts_Type_Float()}
    set {_uniqueStorage()._minStep = newValue}
  }
  /// Returns true if `minStep` has been explicitly set.
  var hasMinStep: Bool {return _storage._minStep != nil}
  /// Clears the value of `minStep`. Subsequent reads from it will return its default value.
  mutating func clearMinStep() {_uniqueStorage()._minStep = nil}

  var stepPrice: Iticapital_ApiMts_Type_Float {
    get {return _storage._stepPrice ?? Iticapital_ApiMts_Type_Float()}
    set {_uniqueStorage()._stepPrice = newValue}
  }
  /// Returns true if `stepPrice` has been explicitly set.
  var hasStepPrice: Bool {return _storage._stepPrice != nil}
  /// Clears the value of `stepPrice`. Subsequent reads from it will return its default value.
  mutating func clearStepPrice() {_uniqueStorage()._stepPrice = nil}

  var decimals: UInt32 {
    get {return _storage._decimals}
    set {_uniqueStorage()._decimals = newValue}
  }

  var tradingStatus: Iticapital_ApiMts_Security_V1_TradingStatus {
    get {return _storage._tradingStatus}
    set {_uniqueStorage()._tradingStatus = newValue}
  }

  /// ISIN code
  var isin: String {
    get {return _storage._isin}
    set {_uniqueStorage()._isin = newValue}
  }

  /// Accrued interest ("NKD") : Annualized yield to maturity calculated for the settlement date for this security
  var accruedInterest: Iticapital_ApiMts_Type_Float {
    get {return _storage._accruedInterest ?? Iticapital_ApiMts_Type_Float()}
    set {_uniqueStorage()._accruedInterest = newValue}
  }
  /// Returns true if `accruedInterest` has been explicitly set.
  var hasAccruedInterest: Bool {return _storage._accruedInterest != nil}
  /// Clears the value of `accruedInterest`. Subsequent reads from it will return its default value.
  mutating func clearAccruedInterest() {_uniqueStorage()._accruedInterest = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "iticapital.api_mts.security.v1"

extension Iticapital_ApiMts_Security_V1_TradingStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TRADING_STATUS_UNSPECIFIED"),
    1: .same(proto: "UNAVAILABLE_FOR_TRADING"),
    2: .same(proto: "OPENING_PERIOD"),
    3: .same(proto: "CLOSING_PERIOD"),
    4: .same(proto: "TRADING"),
    5: .same(proto: "HALT"),
    6: .same(proto: "TRADING_CLOSED"),
  ]
}

extension Iticapital_ApiMts_Security_V1_SecurityType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SECURITY_TYPE_UNSPECIFIED"),
    1: .same(proto: "FUTURES"),
    2: .same(proto: "OPTIONS"),
    3: .same(proto: "STOCK"),
    4: .same(proto: "STOCK_PREFERENCE"),
    5: .same(proto: "BOND_GOVERNMENT"),
    6: .same(proto: "BOND_REGIONAL"),
    7: .same(proto: "BOND_CB"),
    8: .same(proto: "BOND_CORPORATE"),
    9: .same(proto: "BOND_MFO"),
    10: .same(proto: "BOND_EXCHANGE"),
    11: .same(proto: "BOND_MUNICIPAL"),
    12: .same(proto: "MIF_OPEN"),
    13: .same(proto: "MIF_INTERVAL"),
    14: .same(proto: "MIF_CLOSED"),
    15: .same(proto: "MIF_EXCHANGE"),
    16: .same(proto: "DEPOSITARY_RECEIPTS"),
    17: .same(proto: "INDEX"),
    18: .same(proto: "CURRENCY"),
    19: .same(proto: "RTS_STANDARD"),
    20: .same(proto: "ORE"),
    21: .same(proto: "MORTGAGE_SERTIFICATE"),
    22: .same(proto: "ETF"),
  ]
}

extension Iticapital_ApiMts_Security_V1_Currency: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CURRENCY_UNSPECIFIED"),
    1: .same(proto: "RUB"),
    2: .same(proto: "USD"),
    3: .same(proto: "EUR"),
  ]
}

extension Iticapital_ApiMts_Security_V1_ListSecuritiesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListSecuritiesRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iticapital_ApiMts_Security_V1_ListSecuritiesRequest, rhs: Iticapital_ApiMts_Security_V1_ListSecuritiesRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iticapital_ApiMts_Security_V1_ListSecuritiesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListSecuritiesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "securities"),
  ]

  fileprivate class _StorageClass {
    var _status: Google_Rpc_Status? = nil
    var _securities: [Iticapital_ApiMts_Security_V1_Security] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _status = source._status
      _securities = source._securities
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._status)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._securities)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._securities.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._securities, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iticapital_ApiMts_Security_V1_ListSecuritiesResponse, rhs: Iticapital_ApiMts_Security_V1_ListSecuritiesResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._status != rhs_storage._status {return false}
        if _storage._securities != rhs_storage._securities {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iticapital_ApiMts_Security_V1_Security: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Security"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "description"),
    3: .standard(proto: "sec_type"),
    4: .standard(proto: "lot_size"),
    5: .standard(proto: "face_value"),
    7: .standard(proto: "maturity_date"),
    8: .standard(proto: "prev_trade_date"),
    9: .standard(proto: "limit_up"),
    10: .standard(proto: "limit_down"),
    11: .same(proto: "coupon"),
    12: .standard(proto: "coupon_period"),
    13: .standard(proto: "next_coupon"),
    14: .same(proto: "currency"),
    15: .standard(proto: "min_step"),
    16: .standard(proto: "step_price"),
    17: .same(proto: "decimals"),
    18: .standard(proto: "trading_status"),
    19: .same(proto: "isin"),
    20: .standard(proto: "accrued_interest"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _description_p: String = String()
    var _secType: Iticapital_ApiMts_Security_V1_SecurityType = .unspecified
    var _lotSize: UInt32 = 0
    var _faceValue: UInt32 = 0
    var _maturityDate: Google_Type_Date? = nil
    var _prevTradeDate: Google_Type_Date? = nil
    var _limitUp: SwiftProtobuf.Google_Protobuf_DoubleValue? = nil
    var _limitDown: SwiftProtobuf.Google_Protobuf_DoubleValue? = nil
    var _coupon: Iticapital_ApiMts_Type_Float? = nil
    var _couponPeriod: UInt32 = 0
    var _nextCoupon: Google_Type_Date? = nil
    var _currency: Iticapital_ApiMts_Security_V1_Currency = .unspecified
    var _minStep: Iticapital_ApiMts_Type_Float? = nil
    var _stepPrice: Iticapital_ApiMts_Type_Float? = nil
    var _decimals: UInt32 = 0
    var _tradingStatus: Iticapital_ApiMts_Security_V1_TradingStatus = .unspecified
    var _isin: String = String()
    var _accruedInterest: Iticapital_ApiMts_Type_Float? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _description_p = source._description_p
      _secType = source._secType
      _lotSize = source._lotSize
      _faceValue = source._faceValue
      _maturityDate = source._maturityDate
      _prevTradeDate = source._prevTradeDate
      _limitUp = source._limitUp
      _limitDown = source._limitDown
      _coupon = source._coupon
      _couponPeriod = source._couponPeriod
      _nextCoupon = source._nextCoupon
      _currency = source._currency
      _minStep = source._minStep
      _stepPrice = source._stepPrice
      _decimals = source._decimals
      _tradingStatus = source._tradingStatus
      _isin = source._isin
      _accruedInterest = source._accruedInterest
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._name)
        case 2: try decoder.decodeSingularStringField(value: &_storage._description_p)
        case 3: try decoder.decodeSingularEnumField(value: &_storage._secType)
        case 4: try decoder.decodeSingularUInt32Field(value: &_storage._lotSize)
        case 5: try decoder.decodeSingularUInt32Field(value: &_storage._faceValue)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._maturityDate)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._prevTradeDate)
        case 9: try decoder.decodeSingularMessageField(value: &_storage._limitUp)
        case 10: try decoder.decodeSingularMessageField(value: &_storage._limitDown)
        case 11: try decoder.decodeSingularMessageField(value: &_storage._coupon)
        case 12: try decoder.decodeSingularUInt32Field(value: &_storage._couponPeriod)
        case 13: try decoder.decodeSingularMessageField(value: &_storage._nextCoupon)
        case 14: try decoder.decodeSingularEnumField(value: &_storage._currency)
        case 15: try decoder.decodeSingularMessageField(value: &_storage._minStep)
        case 16: try decoder.decodeSingularMessageField(value: &_storage._stepPrice)
        case 17: try decoder.decodeSingularUInt32Field(value: &_storage._decimals)
        case 18: try decoder.decodeSingularEnumField(value: &_storage._tradingStatus)
        case 19: try decoder.decodeSingularStringField(value: &_storage._isin)
        case 20: try decoder.decodeSingularMessageField(value: &_storage._accruedInterest)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 2)
      }
      if _storage._secType != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._secType, fieldNumber: 3)
      }
      if _storage._lotSize != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._lotSize, fieldNumber: 4)
      }
      if _storage._faceValue != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._faceValue, fieldNumber: 5)
      }
      if let v = _storage._maturityDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._prevTradeDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _storage._limitUp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if let v = _storage._limitDown {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if let v = _storage._coupon {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
      if _storage._couponPeriod != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._couponPeriod, fieldNumber: 12)
      }
      if let v = _storage._nextCoupon {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }
      if _storage._currency != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._currency, fieldNumber: 14)
      }
      if let v = _storage._minStep {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
      if let v = _storage._stepPrice {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }
      if _storage._decimals != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._decimals, fieldNumber: 17)
      }
      if _storage._tradingStatus != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._tradingStatus, fieldNumber: 18)
      }
      if !_storage._isin.isEmpty {
        try visitor.visitSingularStringField(value: _storage._isin, fieldNumber: 19)
      }
      if let v = _storage._accruedInterest {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iticapital_ApiMts_Security_V1_Security, rhs: Iticapital_ApiMts_Security_V1_Security) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._secType != rhs_storage._secType {return false}
        if _storage._lotSize != rhs_storage._lotSize {return false}
        if _storage._faceValue != rhs_storage._faceValue {return false}
        if _storage._maturityDate != rhs_storage._maturityDate {return false}
        if _storage._prevTradeDate != rhs_storage._prevTradeDate {return false}
        if _storage._limitUp != rhs_storage._limitUp {return false}
        if _storage._limitDown != rhs_storage._limitDown {return false}
        if _storage._coupon != rhs_storage._coupon {return false}
        if _storage._couponPeriod != rhs_storage._couponPeriod {return false}
        if _storage._nextCoupon != rhs_storage._nextCoupon {return false}
        if _storage._currency != rhs_storage._currency {return false}
        if _storage._minStep != rhs_storage._minStep {return false}
        if _storage._stepPrice != rhs_storage._stepPrice {return false}
        if _storage._decimals != rhs_storage._decimals {return false}
        if _storage._tradingStatus != rhs_storage._tradingStatus {return false}
        if _storage._isin != rhs_storage._isin {return false}
        if _storage._accruedInterest != rhs_storage._accruedInterest {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

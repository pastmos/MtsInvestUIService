// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: trade.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Ru_Mts_Trading_Trade_OperationStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Pending request 
  case operationPending // = 0
  case operationOpen // = 1
  case operationPartiallyFilled // = 2
  case operationCancelled // = 3
  case operationPartiallyCancelled // = 4
  case operationExchange // = 5
  case operationFailedExchange // = 6
  case operationRejectedExchange // = 7
  case operationRejected // = 8
  case operationFailed // = 9
  case operationExecuted // = 10
  case operationExpired // = 11
  case UNRECOGNIZED(Int)

  init() {
    self = .operationPending
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .operationPending
    case 1: self = .operationOpen
    case 2: self = .operationPartiallyFilled
    case 3: self = .operationCancelled
    case 4: self = .operationPartiallyCancelled
    case 5: self = .operationExchange
    case 6: self = .operationFailedExchange
    case 7: self = .operationRejectedExchange
    case 8: self = .operationRejected
    case 9: self = .operationFailed
    case 10: self = .operationExecuted
    case 11: self = .operationExpired
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .operationPending: return 0
    case .operationOpen: return 1
    case .operationPartiallyFilled: return 2
    case .operationCancelled: return 3
    case .operationPartiallyCancelled: return 4
    case .operationExchange: return 5
    case .operationFailedExchange: return 6
    case .operationRejectedExchange: return 7
    case .operationRejected: return 8
    case .operationFailed: return 9
    case .operationExecuted: return 10
    case .operationExpired: return 11
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Ru_Mts_Trading_Trade_OperationStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Ru_Mts_Trading_Trade_OperationStatus] = [
    .operationPending,
    .operationOpen,
    .operationPartiallyFilled,
    .operationCancelled,
    .operationPartiallyCancelled,
    .operationExchange,
    .operationFailedExchange,
    .operationRejectedExchange,
    .operationRejected,
    .operationFailed,
    .operationExecuted,
    .operationExpired,
  ]
}

#endif  // swift(>=4.2)

enum Ru_Mts_Trading_Trade_OperationIntentType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case buyOperation // = 0
  case sellOperation // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .buyOperation
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .buyOperation
    case 1: self = .sellOperation
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .buyOperation: return 0
    case .sellOperation: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Ru_Mts_Trading_Trade_OperationIntentType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Ru_Mts_Trading_Trade_OperationIntentType] = [
    .buyOperation,
    .sellOperation,
  ]
}

#endif  // swift(>=4.2)

enum Ru_Mts_Trading_Trade_PriceSubcriptionType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case buy // = 0
  case sell // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .buy
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .buy
    case 1: self = .sell
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .buy: return 0
    case .sell: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Ru_Mts_Trading_Trade_PriceSubcriptionType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Ru_Mts_Trading_Trade_PriceSubcriptionType] = [
    .buy,
    .sell,
  ]
}

#endif  // swift(>=4.2)

enum Ru_Mts_Trading_Trade_OperationType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case buy // = 0
  case sell // = 1
  case cancel // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .buy
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .buy
    case 1: self = .sell
    case 2: self = .cancel
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .buy: return 0
    case .sell: return 1
    case .cancel: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Ru_Mts_Trading_Trade_OperationType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Ru_Mts_Trading_Trade_OperationType] = [
    .buy,
    .sell,
    .cancel,
  ]
}

#endif  // swift(>=4.2)

enum Ru_Mts_Trading_Trade_OrderStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Pending request 
  case pending // = 0
  case `open` // = 1
  case partiallyFilled // = 2
  case cancelled // = 3
  case closed // = 4
  case rejected // = 5
  case failed // = 6
  case executed // = 7
  case expired // = 8
  case UNRECOGNIZED(Int)

  init() {
    self = .pending
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .pending
    case 1: self = .open
    case 2: self = .partiallyFilled
    case 3: self = .cancelled
    case 4: self = .closed
    case 5: self = .rejected
    case 6: self = .failed
    case 7: self = .executed
    case 8: self = .expired
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .pending: return 0
    case .open: return 1
    case .partiallyFilled: return 2
    case .cancelled: return 3
    case .closed: return 4
    case .rejected: return 5
    case .failed: return 6
    case .executed: return 7
    case .expired: return 8
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Ru_Mts_Trading_Trade_OrderStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Ru_Mts_Trading_Trade_OrderStatus] = [
    .pending,
    .open,
    .partiallyFilled,
    .cancelled,
    .closed,
    .rejected,
    .failed,
    .executed,
    .expired,
  ]
}

#endif  // swift(>=4.2)

struct Ru_Mts_Trading_Trade_CancelOperationIntent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var operationID: Ru_Mts_Trading_Trade_CancelOperationIntent.OneOf_OperationID? = nil

  var orderID: UInt64 {
    get {
      if case .orderID(let v)? = operationID {return v}
      return 0
    }
    set {operationID = .orderID(newValue)}
  }

  var userOrderID: UInt64 {
    get {
      if case .userOrderID(let v)? = operationID {return v}
      return 0
    }
    set {operationID = .userOrderID(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_OperationID: Equatable {
    case orderID(UInt64)
    case userOrderID(UInt64)

  #if !swift(>=4.1)
    static func ==(lhs: Ru_Mts_Trading_Trade_CancelOperationIntent.OneOf_OperationID, rhs: Ru_Mts_Trading_Trade_CancelOperationIntent.OneOf_OperationID) -> Bool {
      switch (lhs, rhs) {
      case (.orderID(let l), .orderID(let r)): return l == r
      case (.userOrderID(let l), .userOrderID(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Ru_Mts_Trading_Trade_HideOperationState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hideOperationID: Ru_Mts_Trading_Trade_HideOperationState.OneOf_HideOperationID? = nil

  var orderID: UInt64 {
    get {
      if case .orderID(let v)? = hideOperationID {return v}
      return 0
    }
    set {hideOperationID = .orderID(newValue)}
  }

  var userOrderID: UInt64 {
    get {
      if case .userOrderID(let v)? = hideOperationID {return v}
      return 0
    }
    set {hideOperationID = .userOrderID(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_HideOperationID: Equatable {
    case orderID(UInt64)
    case userOrderID(UInt64)

  #if !swift(>=4.1)
    static func ==(lhs: Ru_Mts_Trading_Trade_HideOperationState.OneOf_HideOperationID, rhs: Ru_Mts_Trading_Trade_HideOperationState.OneOf_HideOperationID) -> Bool {
      switch (lhs, rhs) {
      case (.orderID(let l), .orderID(let r)): return l == r
      case (.userOrderID(let l), .userOrderID(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Ru_Mts_Trading_Trade_HiddenOperation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var orderID: UInt64 = 0

  var userOrderID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ru_Mts_Trading_Trade_ExecuteOperationIntent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Ok, what do u want?
  var operationType: Ru_Mts_Trading_Trade_OperationIntentType {
    get {return _storage._operationType}
    set {_uniqueStorage()._operationType = newValue}
  }

  /// security name
  var securityName: String {
    get {return _storage._securityName}
    set {_uniqueStorage()._securityName = newValue}
  }

  /// how many do you want to buy/sell?
  var lots: Ru_Mts_Trading_Trade_Price {
    get {return _storage._lots ?? Ru_Mts_Trading_Trade_Price()}
    set {_uniqueStorage()._lots = newValue}
  }
  /// Returns true if `lots` has been explicitly set.
  var hasLots: Bool {return _storage._lots != nil}
  /// Clears the value of `lots`. Subsequent reads from it will return its default value.
  mutating func clearLots() {_uniqueStorage()._lots = nil}

  /// limit price
  var price: Ru_Mts_Trading_Trade_Price {
    get {return _storage._price ?? Ru_Mts_Trading_Trade_Price()}
    set {_uniqueStorage()._price = newValue}
  }
  /// Returns true if `price` has been explicitly set.
  var hasPrice: Bool {return _storage._price != nil}
  /// Clears the value of `price`. Subsequent reads from it will return its default value.
  mutating func clearPrice() {_uniqueStorage()._price = nil}

  var currencyCode: GrpcCurrency {
    get {return _storage._currencyCode ?? GrpcCurrency()}
    set {_uniqueStorage()._currencyCode = newValue}
  }
  /// Returns true if `currencyCode` has been explicitly set.
  var hasCurrencyCode: Bool {return _storage._currencyCode != nil}
  /// Clears the value of `currencyCode`. Subsequent reads from it will return its default value.
  mutating func clearCurrencyCode() {_uniqueStorage()._currencyCode = nil}

  /// user's order id
  var userOrderID: UInt64 {
    get {return _storage._userOrderID}
    set {_uniqueStorage()._userOrderID = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Ru_Mts_Trading_Trade_OperationIntent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var intent: OneOf_Intent? {
    get {return _storage._intent}
    set {_uniqueStorage()._intent = newValue}
  }

  var execute: Ru_Mts_Trading_Trade_ExecuteOperationIntent {
    get {
      if case .execute(let v)? = _storage._intent {return v}
      return Ru_Mts_Trading_Trade_ExecuteOperationIntent()
    }
    set {_uniqueStorage()._intent = .execute(newValue)}
  }

  var cancel: Ru_Mts_Trading_Trade_CancelOperationIntent {
    get {
      if case .cancel(let v)? = _storage._intent {return v}
      return Ru_Mts_Trading_Trade_CancelOperationIntent()
    }
    set {_uniqueStorage()._intent = .cancel(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Intent: Equatable {
    case execute(Ru_Mts_Trading_Trade_ExecuteOperationIntent)
    case cancel(Ru_Mts_Trading_Trade_CancelOperationIntent)

  #if !swift(>=4.1)
    static func ==(lhs: Ru_Mts_Trading_Trade_OperationIntent.OneOf_Intent, rhs: Ru_Mts_Trading_Trade_OperationIntent.OneOf_Intent) -> Bool {
      switch (lhs, rhs) {
      case (.execute(let l), .execute(let r)): return l == r
      case (.cancel(let l), .cancel(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Ru_Mts_Trading_Trade_OperationState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var data: Ru_Mts_Trading_Trade_OperationStateData {
    get {return _storage._data ?? Ru_Mts_Trading_Trade_OperationStateData()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  mutating func clearData() {_uniqueStorage()._data = nil}

  var error: Ru_Mts_Trading_Trade_OperationError {
    get {return _storage._error ?? Ru_Mts_Trading_Trade_OperationError()}
    set {_uniqueStorage()._error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return _storage._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {_uniqueStorage()._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Ru_Mts_Trading_Trade_OperationStateData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var orderID: UInt64 {
    get {return _storage._orderID}
    set {_uniqueStorage()._orderID = newValue}
  }

  /// user's order id
  var userOrderID: UInt64 {
    get {return _storage._userOrderID}
    set {_uniqueStorage()._userOrderID = newValue}
  }

  var exchangeOrderID: String {
    get {return _storage._exchangeOrderID}
    set {_uniqueStorage()._exchangeOrderID = newValue}
  }

  /// Ok, what do u want?
  var operationType: Ru_Mts_Trading_Trade_OperationIntentType {
    get {return _storage._operationType}
    set {_uniqueStorage()._operationType = newValue}
  }

  var status: Ru_Mts_Trading_Trade_OperationStatus {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  /// security name
  var securityName: String {
    get {return _storage._securityName}
    set {_uniqueStorage()._securityName = newValue}
  }

  /// how many do you want to buy/sell?
  var lots: Ru_Mts_Trading_Trade_Price {
    get {return _storage._lots ?? Ru_Mts_Trading_Trade_Price()}
    set {_uniqueStorage()._lots = newValue}
  }
  /// Returns true if `lots` has been explicitly set.
  var hasLots: Bool {return _storage._lots != nil}
  /// Clears the value of `lots`. Subsequent reads from it will return its default value.
  mutating func clearLots() {_uniqueStorage()._lots = nil}

  /// how many do you want to buy/sell?
  var executedLots: Ru_Mts_Trading_Trade_Price {
    get {return _storage._executedLots ?? Ru_Mts_Trading_Trade_Price()}
    set {_uniqueStorage()._executedLots = newValue}
  }
  /// Returns true if `executedLots` has been explicitly set.
  var hasExecutedLots: Bool {return _storage._executedLots != nil}
  /// Clears the value of `executedLots`. Subsequent reads from it will return its default value.
  mutating func clearExecutedLots() {_uniqueStorage()._executedLots = nil}

  /// limit price
  var originalLimitPrice: Ru_Mts_Trading_Trade_Price {
    get {return _storage._originalLimitPrice ?? Ru_Mts_Trading_Trade_Price()}
    set {_uniqueStorage()._originalLimitPrice = newValue}
  }
  /// Returns true if `originalLimitPrice` has been explicitly set.
  var hasOriginalLimitPrice: Bool {return _storage._originalLimitPrice != nil}
  /// Clears the value of `originalLimitPrice`. Subsequent reads from it will return its default value.
  mutating func clearOriginalLimitPrice() {_uniqueStorage()._originalLimitPrice = nil}

  /// limit price
  var originalExecutedPrice: Ru_Mts_Trading_Trade_Price {
    get {return _storage._originalExecutedPrice ?? Ru_Mts_Trading_Trade_Price()}
    set {_uniqueStorage()._originalExecutedPrice = newValue}
  }
  /// Returns true if `originalExecutedPrice` has been explicitly set.
  var hasOriginalExecutedPrice: Bool {return _storage._originalExecutedPrice != nil}
  /// Clears the value of `originalExecutedPrice`. Subsequent reads from it will return its default value.
  mutating func clearOriginalExecutedPrice() {_uniqueStorage()._originalExecutedPrice = nil}

  /// limit price
  var targetLimitPrice: Ru_Mts_Trading_Trade_Price {
    get {return _storage._targetLimitPrice ?? Ru_Mts_Trading_Trade_Price()}
    set {_uniqueStorage()._targetLimitPrice = newValue}
  }
  /// Returns true if `targetLimitPrice` has been explicitly set.
  var hasTargetLimitPrice: Bool {return _storage._targetLimitPrice != nil}
  /// Clears the value of `targetLimitPrice`. Subsequent reads from it will return its default value.
  mutating func clearTargetLimitPrice() {_uniqueStorage()._targetLimitPrice = nil}

  /// limit price
  var targetExecutedPrice: Ru_Mts_Trading_Trade_Price {
    get {return _storage._targetExecutedPrice ?? Ru_Mts_Trading_Trade_Price()}
    set {_uniqueStorage()._targetExecutedPrice = newValue}
  }
  /// Returns true if `targetExecutedPrice` has been explicitly set.
  var hasTargetExecutedPrice: Bool {return _storage._targetExecutedPrice != nil}
  /// Clears the value of `targetExecutedPrice`. Subsequent reads from it will return its default value.
  mutating func clearTargetExecutedPrice() {_uniqueStorage()._targetExecutedPrice = nil}

  /// exchange rate
  var exchangeRate: Ru_Mts_Trading_Trade_Price {
    get {return _storage._exchangeRate ?? Ru_Mts_Trading_Trade_Price()}
    set {_uniqueStorage()._exchangeRate = newValue}
  }
  /// Returns true if `exchangeRate` has been explicitly set.
  var hasExchangeRate: Bool {return _storage._exchangeRate != nil}
  /// Clears the value of `exchangeRate`. Subsequent reads from it will return its default value.
  mutating func clearExchangeRate() {_uniqueStorage()._exchangeRate = nil}

  var targetCurrency: GrpcCurrency {
    get {return _storage._targetCurrency ?? GrpcCurrency()}
    set {_uniqueStorage()._targetCurrency = newValue}
  }
  /// Returns true if `targetCurrency` has been explicitly set.
  var hasTargetCurrency: Bool {return _storage._targetCurrency != nil}
  /// Clears the value of `targetCurrency`. Subsequent reads from it will return its default value.
  mutating func clearTargetCurrency() {_uniqueStorage()._targetCurrency = nil}

  var originalCurrency: GrpcCurrency {
    get {return _storage._originalCurrency ?? GrpcCurrency()}
    set {_uniqueStorage()._originalCurrency = newValue}
  }
  /// Returns true if `originalCurrency` has been explicitly set.
  var hasOriginalCurrency: Bool {return _storage._originalCurrency != nil}
  /// Clears the value of `originalCurrency`. Subsequent reads from it will return its default value.
  mutating func clearOriginalCurrency() {_uniqueStorage()._originalCurrency = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Ru_Mts_Trading_Trade_OperationError {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var errorCode: UInt64 = 0

  var error: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ru_Mts_Trading_Trade_PriceChangeSubsriptionSingleRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var requests: [Ru_Mts_Trading_Trade_PriceChangeSubsriptionRequest] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Subcription request
struct Ru_Mts_Trading_Trade_PriceChangeSubsriptionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// security name
  var securityName: String {
    get {return _storage._securityName}
    set {_uniqueStorage()._securityName = newValue}
  }

  /// subcribe for selling or buying?
  var operation: Ru_Mts_Trading_Trade_PriceSubcriptionType {
    get {return _storage._operation}
    set {_uniqueStorage()._operation = newValue}
  }

  /// a currency to be used
  var currencyCode: GrpcCurrency {
    get {return _storage._currencyCode ?? GrpcCurrency()}
    set {_uniqueStorage()._currencyCode = newValue}
  }
  /// Returns true if `currencyCode` has been explicitly set.
  var hasCurrencyCode: Bool {return _storage._currencyCode != nil}
  /// Clears the value of `currencyCode`. Subsequent reads from it will return its default value.
  mutating func clearCurrencyCode() {_uniqueStorage()._currencyCode = nil}

  /// how many lots you intent to buy/sell
  var lots: Ru_Mts_Trading_Trade_Price {
    get {return _storage._lots ?? Ru_Mts_Trading_Trade_Price()}
    set {_uniqueStorage()._lots = newValue}
  }
  /// Returns true if `lots` has been explicitly set.
  var hasLots: Bool {return _storage._lots != nil}
  /// Clears the value of `lots`. Subsequent reads from it will return its default value.
  mutating func clearLots() {_uniqueStorage()._lots = nil}

  /// subcription id 4 you
  var subscriptionID: UInt64 {
    get {return _storage._subscriptionID}
    set {_uniqueStorage()._subscriptionID = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Ru_Mts_Trading_Trade_CancelPriceChangeSubsriptionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// subcription id 4 you
  var subscriptionID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ru_Mts_Trading_Trade_PriceWatchSubcriptionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subcriptionRequest: OneOf_SubcriptionRequest? {
    get {return _storage._subcriptionRequest}
    set {_uniqueStorage()._subcriptionRequest = newValue}
  }

  var subcribeRequest: Ru_Mts_Trading_Trade_PriceChangeSubsriptionRequest {
    get {
      if case .subcribeRequest(let v)? = _storage._subcriptionRequest {return v}
      return Ru_Mts_Trading_Trade_PriceChangeSubsriptionRequest()
    }
    set {_uniqueStorage()._subcriptionRequest = .subcribeRequest(newValue)}
  }

  var cancelSubscriptionRequest: Ru_Mts_Trading_Trade_CancelPriceChangeSubsriptionRequest {
    get {
      if case .cancelSubscriptionRequest(let v)? = _storage._subcriptionRequest {return v}
      return Ru_Mts_Trading_Trade_CancelPriceChangeSubsriptionRequest()
    }
    set {_uniqueStorage()._subcriptionRequest = .cancelSubscriptionRequest(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_SubcriptionRequest: Equatable {
    case subcribeRequest(Ru_Mts_Trading_Trade_PriceChangeSubsriptionRequest)
    case cancelSubscriptionRequest(Ru_Mts_Trading_Trade_CancelPriceChangeSubsriptionRequest)

  #if !swift(>=4.1)
    static func ==(lhs: Ru_Mts_Trading_Trade_PriceWatchSubcriptionRequest.OneOf_SubcriptionRequest, rhs: Ru_Mts_Trading_Trade_PriceWatchSubcriptionRequest.OneOf_SubcriptionRequest) -> Bool {
      switch (lhs, rhs) {
      case (.subcribeRequest(let l), .subcribeRequest(let r)): return l == r
      case (.cancelSubscriptionRequest(let l), .cancelSubscriptionRequest(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Ru_Mts_Trading_Trade_PriceChange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subcriptionRequest: OneOf_SubcriptionRequest? {
    get {return _storage._subcriptionRequest}
    set {_uniqueStorage()._subcriptionRequest = newValue}
  }

  var change: Ru_Mts_Trading_Trade_PriceChangeData {
    get {
      if case .change(let v)? = _storage._subcriptionRequest {return v}
      return Ru_Mts_Trading_Trade_PriceChangeData()
    }
    set {_uniqueStorage()._subcriptionRequest = .change(newValue)}
  }

  var error: Ru_Mts_Trading_Trade_PriceChangeError {
    get {
      if case .error(let v)? = _storage._subcriptionRequest {return v}
      return Ru_Mts_Trading_Trade_PriceChangeError()
    }
    set {_uniqueStorage()._subcriptionRequest = .error(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_SubcriptionRequest: Equatable {
    case change(Ru_Mts_Trading_Trade_PriceChangeData)
    case error(Ru_Mts_Trading_Trade_PriceChangeError)

  #if !swift(>=4.1)
    static func ==(lhs: Ru_Mts_Trading_Trade_PriceChange.OneOf_SubcriptionRequest, rhs: Ru_Mts_Trading_Trade_PriceChange.OneOf_SubcriptionRequest) -> Bool {
      switch (lhs, rhs) {
      case (.change(let l), .change(let r)): return l == r
      case (.error(let l), .error(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Ru_Mts_Trading_Trade_PriceChangeError {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subscriptionID: UInt64 = 0

  var errorCode: UInt64 = 0

  var error: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ru_Mts_Trading_Trade_PriceChangeData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subscriptionID: UInt64 {
    get {return _storage._subscriptionID}
    set {_uniqueStorage()._subscriptionID = newValue}
  }

  var originalCurrencyPrice: Ru_Mts_Trading_Trade_Price {
    get {return _storage._originalCurrencyPrice ?? Ru_Mts_Trading_Trade_Price()}
    set {_uniqueStorage()._originalCurrencyPrice = newValue}
  }
  /// Returns true if `originalCurrencyPrice` has been explicitly set.
  var hasOriginalCurrencyPrice: Bool {return _storage._originalCurrencyPrice != nil}
  /// Clears the value of `originalCurrencyPrice`. Subsequent reads from it will return its default value.
  mutating func clearOriginalCurrencyPrice() {_uniqueStorage()._originalCurrencyPrice = nil}

  var targetCurrencyPrice: Ru_Mts_Trading_Trade_Price {
    get {return _storage._targetCurrencyPrice ?? Ru_Mts_Trading_Trade_Price()}
    set {_uniqueStorage()._targetCurrencyPrice = newValue}
  }
  /// Returns true if `targetCurrencyPrice` has been explicitly set.
  var hasTargetCurrencyPrice: Bool {return _storage._targetCurrencyPrice != nil}
  /// Clears the value of `targetCurrencyPrice`. Subsequent reads from it will return its default value.
  mutating func clearTargetCurrencyPrice() {_uniqueStorage()._targetCurrencyPrice = nil}

  var exchangeRate: Ru_Mts_Trading_Trade_Price {
    get {return _storage._exchangeRate ?? Ru_Mts_Trading_Trade_Price()}
    set {_uniqueStorage()._exchangeRate = newValue}
  }
  /// Returns true if `exchangeRate` has been explicitly set.
  var hasExchangeRate: Bool {return _storage._exchangeRate != nil}
  /// Clears the value of `exchangeRate`. Subsequent reads from it will return its default value.
  mutating func clearExchangeRate() {_uniqueStorage()._exchangeRate = nil}

  var lots: Ru_Mts_Trading_Trade_Price {
    get {return _storage._lots ?? Ru_Mts_Trading_Trade_Price()}
    set {_uniqueStorage()._lots = newValue}
  }
  /// Returns true if `lots` has been explicitly set.
  var hasLots: Bool {return _storage._lots != nil}
  /// Clears the value of `lots`. Subsequent reads from it will return its default value.
  mutating func clearLots() {_uniqueStorage()._lots = nil}

  var commission: Ru_Mts_Trading_Trade_Price {
    get {return _storage._commission ?? Ru_Mts_Trading_Trade_Price()}
    set {_uniqueStorage()._commission = newValue}
  }
  /// Returns true if `commission` has been explicitly set.
  var hasCommission: Bool {return _storage._commission != nil}
  /// Clears the value of `commission`. Subsequent reads from it will return its default value.
  mutating func clearCommission() {_uniqueStorage()._commission = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Ru_Mts_Trading_Trade_HideRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// prefered
  var orderIds: [UInt64] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ru_Mts_Trading_Trade_HideResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ru_Mts_Trading_Trade_WatchRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: Ru_Mts_Trading_Trade_OperationType = .buy

  var quantity: UInt32 = 0

  var securityName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ru_Mts_Trading_Trade_WatchPrice {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: Ru_Mts_Trading_Trade_OperationType {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  var securityName: String {
    get {return _storage._securityName}
    set {_uniqueStorage()._securityName = newValue}
  }

  /// depricated
  var doublePrice: Double {
    get {return _storage._doublePrice}
    set {_uniqueStorage()._doublePrice = newValue}
  }

  var quantity: UInt64 {
    get {return _storage._quantity}
    set {_uniqueStorage()._quantity = newValue}
  }

  var price: Ru_Mts_Trading_Trade_Price {
    get {return _storage._price ?? Ru_Mts_Trading_Trade_Price()}
    set {_uniqueStorage()._price = newValue}
  }
  /// Returns true if `price` has been explicitly set.
  var hasPrice: Bool {return _storage._price != nil}
  /// Clears the value of `price`. Subsequent reads from it will return its default value.
  mutating func clearPrice() {_uniqueStorage()._price = nil}

  var bid: Ru_Mts_Trading_Trade_Price {
    get {return _storage._bid ?? Ru_Mts_Trading_Trade_Price()}
    set {_uniqueStorage()._bid = newValue}
  }
  /// Returns true if `bid` has been explicitly set.
  var hasBid: Bool {return _storage._bid != nil}
  /// Clears the value of `bid`. Subsequent reads from it will return its default value.
  mutating func clearBid() {_uniqueStorage()._bid = nil}

  var ask: Ru_Mts_Trading_Trade_Price {
    get {return _storage._ask ?? Ru_Mts_Trading_Trade_Price()}
    set {_uniqueStorage()._ask = newValue}
  }
  /// Returns true if `ask` has been explicitly set.
  var hasAsk: Bool {return _storage._ask != nil}
  /// Clears the value of `ask`. Subsequent reads from it will return its default value.
  mutating func clearAsk() {_uniqueStorage()._ask = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Ru_Mts_Trading_Trade_Price {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var price: UInt64 = 0

  var scale: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ru_Mts_Trading_Trade_TradingOperation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Ok, what do u want?
  var type: Ru_Mts_Trading_Trade_OperationType {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  /// how many do you want to buy/sell?
  var quantity: UInt32 {
    get {return _storage._quantity}
    set {_uniqueStorage()._quantity = newValue}
  }

  /// security name
  var securityName: String {
    get {return _storage._securityName}
    set {_uniqueStorage()._securityName = newValue}
  }

  /// only for cancel operation
  var orderID: UInt64 {
    get {return _storage._orderID}
    set {_uniqueStorage()._orderID = newValue}
  }

  /// this field will help you with order's context
  var localID: UInt64 {
    get {return _storage._localID}
    set {_uniqueStorage()._localID = newValue}
  }

  /// limit price
  var price: Double {
    get {return _storage._price}
    set {_uniqueStorage()._price = newValue}
  }

  var priceValue: Ru_Mts_Trading_Trade_Price {
    get {return _storage._priceValue ?? Ru_Mts_Trading_Trade_Price()}
    set {_uniqueStorage()._priceValue = newValue}
  }
  /// Returns true if `priceValue` has been explicitly set.
  var hasPriceValue: Bool {return _storage._priceValue != nil}
  /// Clears the value of `priceValue`. Subsequent reads from it will return its default value.
  mutating func clearPriceValue() {_uniqueStorage()._priceValue = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Ru_Mts_Trading_Trade_Order {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// real order id
  var orderID: UInt64 {
    get {return _storage._orderID}
    set {_uniqueStorage()._orderID = newValue}
  }

  /// LocalId is field that could be any, and may be setted by the API's user
  var localID: UInt64 {
    get {return _storage._localID}
    set {_uniqueStorage()._localID = newValue}
  }

  var type: Ru_Mts_Trading_Trade_OperationType {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  /// security name
  var securityName: String {
    get {return _storage._securityName}
    set {_uniqueStorage()._securityName = newValue}
  }

  /// limit price
  var price: Double {
    get {return _storage._price}
    set {_uniqueStorage()._price = newValue}
  }

  /// current status
  var status: Ru_Mts_Trading_Trade_OrderStatus {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  /// Exists only when order is PartiallyFilled or Closed, otherwise it is zero
  var realPrice: Ru_Mts_Trading_Trade_Price {
    get {return _storage._realPrice ?? Ru_Mts_Trading_Trade_Price()}
    set {_uniqueStorage()._realPrice = newValue}
  }
  /// Returns true if `realPrice` has been explicitly set.
  var hasRealPrice: Bool {return _storage._realPrice != nil}
  /// Clears the value of `realPrice`. Subsequent reads from it will return its default value.
  mutating func clearRealPrice() {_uniqueStorage()._realPrice = nil}

  /// lots
  var lots: UInt64 {
    get {return _storage._lots}
    set {_uniqueStorage()._lots = newValue}
  }

  /// message associated with order
  var message: String {
    get {return _storage._message}
    set {_uniqueStorage()._message = newValue}
  }

  /// amount of excuted lots at the moment
  var executedLots: UInt64 {
    get {return _storage._executedLots}
    set {_uniqueStorage()._executedLots = newValue}
  }

  /// sends once after hide
  var hidden: Bool {
    get {return _storage._hidden}
    set {_uniqueStorage()._hidden = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "ru.mts.trading.trade"

extension Ru_Mts_Trading_Trade_OperationStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OPERATION_PENDING"),
    1: .same(proto: "OPERATION_OPEN"),
    2: .same(proto: "OPERATION_PARTIALLY_FILLED"),
    3: .same(proto: "OPERATION_CANCELLED"),
    4: .same(proto: "OPERATION_PARTIALLY_CANCELLED"),
    5: .same(proto: "OPERATION_EXCHANGE"),
    6: .same(proto: "OPERATION_FAILED_EXCHANGE"),
    7: .same(proto: "OPERATION_REJECTED_EXCHANGE"),
    8: .same(proto: "OPERATION_REJECTED"),
    9: .same(proto: "OPERATION_FAILED"),
    10: .same(proto: "OPERATION_EXECUTED"),
    11: .same(proto: "OPERATION_EXPIRED"),
  ]
}

extension Ru_Mts_Trading_Trade_OperationIntentType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BUY_OPERATION"),
    1: .same(proto: "SELL_OPERATION"),
  ]
}

extension Ru_Mts_Trading_Trade_PriceSubcriptionType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BUY"),
    1: .same(proto: "SELL"),
  ]
}

extension Ru_Mts_Trading_Trade_OperationType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Buy"),
    1: .same(proto: "Sell"),
    2: .same(proto: "Cancel"),
  ]
}

extension Ru_Mts_Trading_Trade_OrderStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Pending"),
    1: .same(proto: "Open"),
    2: .same(proto: "PartiallyFilled"),
    3: .same(proto: "Cancelled"),
    4: .same(proto: "Closed"),
    5: .same(proto: "Rejected"),
    6: .same(proto: "Failed"),
    7: .same(proto: "Executed"),
    8: .same(proto: "Expired"),
  ]
}

extension Ru_Mts_Trading_Trade_CancelOperationIntent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CancelOperationIntent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "orderId"),
    2: .same(proto: "userOrderId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        if self.operationID != nil {try decoder.handleConflictingOneOf()}
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {self.operationID = .orderID(v)}
      case 2:
        if self.operationID != nil {try decoder.handleConflictingOneOf()}
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {self.operationID = .userOrderID(v)}
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self.operationID {
    case .orderID(let v)?:
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    case .userOrderID(let v)?:
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ru_Mts_Trading_Trade_CancelOperationIntent, rhs: Ru_Mts_Trading_Trade_CancelOperationIntent) -> Bool {
    if lhs.operationID != rhs.operationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ru_Mts_Trading_Trade_HideOperationState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HideOperationState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "orderId"),
    2: .same(proto: "userOrderId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        if self.hideOperationID != nil {try decoder.handleConflictingOneOf()}
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {self.hideOperationID = .orderID(v)}
      case 2:
        if self.hideOperationID != nil {try decoder.handleConflictingOneOf()}
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {self.hideOperationID = .userOrderID(v)}
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self.hideOperationID {
    case .orderID(let v)?:
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    case .userOrderID(let v)?:
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ru_Mts_Trading_Trade_HideOperationState, rhs: Ru_Mts_Trading_Trade_HideOperationState) -> Bool {
    if lhs.hideOperationID != rhs.hideOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ru_Mts_Trading_Trade_HiddenOperation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HiddenOperation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "orderId"),
    2: .same(proto: "userOrderId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.orderID)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.userOrderID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.orderID != 0 {
      try visitor.visitSingularUInt64Field(value: self.orderID, fieldNumber: 1)
    }
    if self.userOrderID != 0 {
      try visitor.visitSingularUInt64Field(value: self.userOrderID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ru_Mts_Trading_Trade_HiddenOperation, rhs: Ru_Mts_Trading_Trade_HiddenOperation) -> Bool {
    if lhs.orderID != rhs.orderID {return false}
    if lhs.userOrderID != rhs.userOrderID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ru_Mts_Trading_Trade_ExecuteOperationIntent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExecuteOperationIntent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operationType"),
    2: .same(proto: "securityName"),
    3: .same(proto: "lots"),
    4: .same(proto: "price"),
    5: .same(proto: "currencyCode"),
    6: .same(proto: "userOrderId"),
  ]

  fileprivate class _StorageClass {
    var _operationType: Ru_Mts_Trading_Trade_OperationIntentType = .buyOperation
    var _securityName: String = String()
    var _lots: Ru_Mts_Trading_Trade_Price? = nil
    var _price: Ru_Mts_Trading_Trade_Price? = nil
    var _currencyCode: GrpcCurrency? = nil
    var _userOrderID: UInt64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _operationType = source._operationType
      _securityName = source._securityName
      _lots = source._lots
      _price = source._price
      _currencyCode = source._currencyCode
      _userOrderID = source._userOrderID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._operationType)
        case 2: try decoder.decodeSingularStringField(value: &_storage._securityName)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._lots)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._price)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._currencyCode)
        case 6: try decoder.decodeSingularUInt64Field(value: &_storage._userOrderID)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._operationType != .buyOperation {
        try visitor.visitSingularEnumField(value: _storage._operationType, fieldNumber: 1)
      }
      if !_storage._securityName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._securityName, fieldNumber: 2)
      }
      if let v = _storage._lots {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._price {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._currencyCode {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if _storage._userOrderID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._userOrderID, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ru_Mts_Trading_Trade_ExecuteOperationIntent, rhs: Ru_Mts_Trading_Trade_ExecuteOperationIntent) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._operationType != rhs_storage._operationType {return false}
        if _storage._securityName != rhs_storage._securityName {return false}
        if _storage._lots != rhs_storage._lots {return false}
        if _storage._price != rhs_storage._price {return false}
        if _storage._currencyCode != rhs_storage._currencyCode {return false}
        if _storage._userOrderID != rhs_storage._userOrderID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ru_Mts_Trading_Trade_OperationIntent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OperationIntent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "execute"),
    2: .same(proto: "cancel"),
  ]

  fileprivate class _StorageClass {
    var _intent: Ru_Mts_Trading_Trade_OperationIntent.OneOf_Intent?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _intent = source._intent
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Ru_Mts_Trading_Trade_ExecuteOperationIntent?
          if let current = _storage._intent {
            try decoder.handleConflictingOneOf()
            if case .execute(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._intent = .execute(v)}
        case 2:
          var v: Ru_Mts_Trading_Trade_CancelOperationIntent?
          if let current = _storage._intent {
            try decoder.handleConflictingOneOf()
            if case .cancel(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._intent = .cancel(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._intent {
      case .execute(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .cancel(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ru_Mts_Trading_Trade_OperationIntent, rhs: Ru_Mts_Trading_Trade_OperationIntent) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._intent != rhs_storage._intent {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ru_Mts_Trading_Trade_OperationState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OperationState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
    2: .same(proto: "error"),
  ]

  fileprivate class _StorageClass {
    var _data: Ru_Mts_Trading_Trade_OperationStateData? = nil
    var _error: Ru_Mts_Trading_Trade_OperationError? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _data = source._data
      _error = source._error
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._data)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._error)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._error {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ru_Mts_Trading_Trade_OperationState, rhs: Ru_Mts_Trading_Trade_OperationState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._data != rhs_storage._data {return false}
        if _storage._error != rhs_storage._error {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ru_Mts_Trading_Trade_OperationStateData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OperationStateData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "orderId"),
    2: .same(proto: "userOrderId"),
    3: .same(proto: "exchangeOrderId"),
    4: .same(proto: "operationType"),
    5: .same(proto: "status"),
    6: .same(proto: "securityName"),
    7: .same(proto: "lots"),
    8: .same(proto: "executedLots"),
    9: .same(proto: "originalLimitPrice"),
    10: .same(proto: "originalExecutedPrice"),
    11: .same(proto: "targetLimitPrice"),
    12: .same(proto: "targetExecutedPrice"),
    13: .same(proto: "exchangeRate"),
    14: .same(proto: "targetCurrency"),
    15: .same(proto: "originalCurrency"),
  ]

  fileprivate class _StorageClass {
    var _orderID: UInt64 = 0
    var _userOrderID: UInt64 = 0
    var _exchangeOrderID: String = String()
    var _operationType: Ru_Mts_Trading_Trade_OperationIntentType = .buyOperation
    var _status: Ru_Mts_Trading_Trade_OperationStatus = .operationPending
    var _securityName: String = String()
    var _lots: Ru_Mts_Trading_Trade_Price? = nil
    var _executedLots: Ru_Mts_Trading_Trade_Price? = nil
    var _originalLimitPrice: Ru_Mts_Trading_Trade_Price? = nil
    var _originalExecutedPrice: Ru_Mts_Trading_Trade_Price? = nil
    var _targetLimitPrice: Ru_Mts_Trading_Trade_Price? = nil
    var _targetExecutedPrice: Ru_Mts_Trading_Trade_Price? = nil
    var _exchangeRate: Ru_Mts_Trading_Trade_Price? = nil
    var _targetCurrency: GrpcCurrency? = nil
    var _originalCurrency: GrpcCurrency? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _orderID = source._orderID
      _userOrderID = source._userOrderID
      _exchangeOrderID = source._exchangeOrderID
      _operationType = source._operationType
      _status = source._status
      _securityName = source._securityName
      _lots = source._lots
      _executedLots = source._executedLots
      _originalLimitPrice = source._originalLimitPrice
      _originalExecutedPrice = source._originalExecutedPrice
      _targetLimitPrice = source._targetLimitPrice
      _targetExecutedPrice = source._targetExecutedPrice
      _exchangeRate = source._exchangeRate
      _targetCurrency = source._targetCurrency
      _originalCurrency = source._originalCurrency
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt64Field(value: &_storage._orderID)
        case 2: try decoder.decodeSingularUInt64Field(value: &_storage._userOrderID)
        case 3: try decoder.decodeSingularStringField(value: &_storage._exchangeOrderID)
        case 4: try decoder.decodeSingularEnumField(value: &_storage._operationType)
        case 5: try decoder.decodeSingularEnumField(value: &_storage._status)
        case 6: try decoder.decodeSingularStringField(value: &_storage._securityName)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._lots)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._executedLots)
        case 9: try decoder.decodeSingularMessageField(value: &_storage._originalLimitPrice)
        case 10: try decoder.decodeSingularMessageField(value: &_storage._originalExecutedPrice)
        case 11: try decoder.decodeSingularMessageField(value: &_storage._targetLimitPrice)
        case 12: try decoder.decodeSingularMessageField(value: &_storage._targetExecutedPrice)
        case 13: try decoder.decodeSingularMessageField(value: &_storage._exchangeRate)
        case 14: try decoder.decodeSingularMessageField(value: &_storage._targetCurrency)
        case 15: try decoder.decodeSingularMessageField(value: &_storage._originalCurrency)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._orderID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._orderID, fieldNumber: 1)
      }
      if _storage._userOrderID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._userOrderID, fieldNumber: 2)
      }
      if !_storage._exchangeOrderID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._exchangeOrderID, fieldNumber: 3)
      }
      if _storage._operationType != .buyOperation {
        try visitor.visitSingularEnumField(value: _storage._operationType, fieldNumber: 4)
      }
      if _storage._status != .operationPending {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 5)
      }
      if !_storage._securityName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._securityName, fieldNumber: 6)
      }
      if let v = _storage._lots {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._executedLots {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _storage._originalLimitPrice {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if let v = _storage._originalExecutedPrice {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if let v = _storage._targetLimitPrice {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
      if let v = _storage._targetExecutedPrice {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }
      if let v = _storage._exchangeRate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }
      if let v = _storage._targetCurrency {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }
      if let v = _storage._originalCurrency {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ru_Mts_Trading_Trade_OperationStateData, rhs: Ru_Mts_Trading_Trade_OperationStateData) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._orderID != rhs_storage._orderID {return false}
        if _storage._userOrderID != rhs_storage._userOrderID {return false}
        if _storage._exchangeOrderID != rhs_storage._exchangeOrderID {return false}
        if _storage._operationType != rhs_storage._operationType {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._securityName != rhs_storage._securityName {return false}
        if _storage._lots != rhs_storage._lots {return false}
        if _storage._executedLots != rhs_storage._executedLots {return false}
        if _storage._originalLimitPrice != rhs_storage._originalLimitPrice {return false}
        if _storage._originalExecutedPrice != rhs_storage._originalExecutedPrice {return false}
        if _storage._targetLimitPrice != rhs_storage._targetLimitPrice {return false}
        if _storage._targetExecutedPrice != rhs_storage._targetExecutedPrice {return false}
        if _storage._exchangeRate != rhs_storage._exchangeRate {return false}
        if _storage._targetCurrency != rhs_storage._targetCurrency {return false}
        if _storage._originalCurrency != rhs_storage._originalCurrency {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ru_Mts_Trading_Trade_OperationError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OperationError"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "errorCode"),
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.errorCode)
      case 2: try decoder.decodeSingularStringField(value: &self.error)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.errorCode != 0 {
      try visitor.visitSingularUInt64Field(value: self.errorCode, fieldNumber: 1)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ru_Mts_Trading_Trade_OperationError, rhs: Ru_Mts_Trading_Trade_OperationError) -> Bool {
    if lhs.errorCode != rhs.errorCode {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ru_Mts_Trading_Trade_PriceChangeSubsriptionSingleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PriceChangeSubsriptionSingleRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "requests"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.requests)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requests.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.requests, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ru_Mts_Trading_Trade_PriceChangeSubsriptionSingleRequest, rhs: Ru_Mts_Trading_Trade_PriceChangeSubsriptionSingleRequest) -> Bool {
    if lhs.requests != rhs.requests {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ru_Mts_Trading_Trade_PriceChangeSubsriptionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PriceChangeSubsriptionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "securityName"),
    2: .same(proto: "operation"),
    3: .same(proto: "currencyCode"),
    4: .same(proto: "lots"),
    5: .same(proto: "subscriptionId"),
  ]

  fileprivate class _StorageClass {
    var _securityName: String = String()
    var _operation: Ru_Mts_Trading_Trade_PriceSubcriptionType = .buy
    var _currencyCode: GrpcCurrency? = nil
    var _lots: Ru_Mts_Trading_Trade_Price? = nil
    var _subscriptionID: UInt64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _securityName = source._securityName
      _operation = source._operation
      _currencyCode = source._currencyCode
      _lots = source._lots
      _subscriptionID = source._subscriptionID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._securityName)
        case 2: try decoder.decodeSingularEnumField(value: &_storage._operation)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._currencyCode)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._lots)
        case 5: try decoder.decodeSingularUInt64Field(value: &_storage._subscriptionID)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._securityName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._securityName, fieldNumber: 1)
      }
      if _storage._operation != .buy {
        try visitor.visitSingularEnumField(value: _storage._operation, fieldNumber: 2)
      }
      if let v = _storage._currencyCode {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._lots {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if _storage._subscriptionID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._subscriptionID, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ru_Mts_Trading_Trade_PriceChangeSubsriptionRequest, rhs: Ru_Mts_Trading_Trade_PriceChangeSubsriptionRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._securityName != rhs_storage._securityName {return false}
        if _storage._operation != rhs_storage._operation {return false}
        if _storage._currencyCode != rhs_storage._currencyCode {return false}
        if _storage._lots != rhs_storage._lots {return false}
        if _storage._subscriptionID != rhs_storage._subscriptionID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ru_Mts_Trading_Trade_CancelPriceChangeSubsriptionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CancelPriceChangeSubsriptionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subscriptionId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.subscriptionID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.subscriptionID != 0 {
      try visitor.visitSingularUInt64Field(value: self.subscriptionID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ru_Mts_Trading_Trade_CancelPriceChangeSubsriptionRequest, rhs: Ru_Mts_Trading_Trade_CancelPriceChangeSubsriptionRequest) -> Bool {
    if lhs.subscriptionID != rhs.subscriptionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ru_Mts_Trading_Trade_PriceWatchSubcriptionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PriceWatchSubcriptionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subcribeRequest"),
    2: .same(proto: "cancelSubscriptionRequest"),
  ]

  fileprivate class _StorageClass {
    var _subcriptionRequest: Ru_Mts_Trading_Trade_PriceWatchSubcriptionRequest.OneOf_SubcriptionRequest?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _subcriptionRequest = source._subcriptionRequest
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Ru_Mts_Trading_Trade_PriceChangeSubsriptionRequest?
          if let current = _storage._subcriptionRequest {
            try decoder.handleConflictingOneOf()
            if case .subcribeRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._subcriptionRequest = .subcribeRequest(v)}
        case 2:
          var v: Ru_Mts_Trading_Trade_CancelPriceChangeSubsriptionRequest?
          if let current = _storage._subcriptionRequest {
            try decoder.handleConflictingOneOf()
            if case .cancelSubscriptionRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._subcriptionRequest = .cancelSubscriptionRequest(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._subcriptionRequest {
      case .subcribeRequest(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .cancelSubscriptionRequest(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ru_Mts_Trading_Trade_PriceWatchSubcriptionRequest, rhs: Ru_Mts_Trading_Trade_PriceWatchSubcriptionRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._subcriptionRequest != rhs_storage._subcriptionRequest {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ru_Mts_Trading_Trade_PriceChange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PriceChange"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "change"),
    2: .same(proto: "error"),
  ]

  fileprivate class _StorageClass {
    var _subcriptionRequest: Ru_Mts_Trading_Trade_PriceChange.OneOf_SubcriptionRequest?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _subcriptionRequest = source._subcriptionRequest
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Ru_Mts_Trading_Trade_PriceChangeData?
          if let current = _storage._subcriptionRequest {
            try decoder.handleConflictingOneOf()
            if case .change(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._subcriptionRequest = .change(v)}
        case 2:
          var v: Ru_Mts_Trading_Trade_PriceChangeError?
          if let current = _storage._subcriptionRequest {
            try decoder.handleConflictingOneOf()
            if case .error(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._subcriptionRequest = .error(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._subcriptionRequest {
      case .change(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .error(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ru_Mts_Trading_Trade_PriceChange, rhs: Ru_Mts_Trading_Trade_PriceChange) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._subcriptionRequest != rhs_storage._subcriptionRequest {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ru_Mts_Trading_Trade_PriceChangeError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PriceChangeError"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subscriptionId"),
    2: .same(proto: "errorCode"),
    3: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.subscriptionID)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.errorCode)
      case 3: try decoder.decodeSingularStringField(value: &self.error)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.subscriptionID != 0 {
      try visitor.visitSingularUInt64Field(value: self.subscriptionID, fieldNumber: 1)
    }
    if self.errorCode != 0 {
      try visitor.visitSingularUInt64Field(value: self.errorCode, fieldNumber: 2)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ru_Mts_Trading_Trade_PriceChangeError, rhs: Ru_Mts_Trading_Trade_PriceChangeError) -> Bool {
    if lhs.subscriptionID != rhs.subscriptionID {return false}
    if lhs.errorCode != rhs.errorCode {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ru_Mts_Trading_Trade_PriceChangeData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PriceChangeData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subscriptionId"),
    2: .same(proto: "originalCurrencyPrice"),
    3: .same(proto: "targetCurrencyPrice"),
    4: .same(proto: "exchangeRate"),
    5: .same(proto: "lots"),
    6: .same(proto: "commission"),
  ]

  fileprivate class _StorageClass {
    var _subscriptionID: UInt64 = 0
    var _originalCurrencyPrice: Ru_Mts_Trading_Trade_Price? = nil
    var _targetCurrencyPrice: Ru_Mts_Trading_Trade_Price? = nil
    var _exchangeRate: Ru_Mts_Trading_Trade_Price? = nil
    var _lots: Ru_Mts_Trading_Trade_Price? = nil
    var _commission: Ru_Mts_Trading_Trade_Price? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _subscriptionID = source._subscriptionID
      _originalCurrencyPrice = source._originalCurrencyPrice
      _targetCurrencyPrice = source._targetCurrencyPrice
      _exchangeRate = source._exchangeRate
      _lots = source._lots
      _commission = source._commission
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt64Field(value: &_storage._subscriptionID)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._originalCurrencyPrice)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._targetCurrencyPrice)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._exchangeRate)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._lots)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._commission)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._subscriptionID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._subscriptionID, fieldNumber: 1)
      }
      if let v = _storage._originalCurrencyPrice {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._targetCurrencyPrice {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._exchangeRate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._lots {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._commission {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ru_Mts_Trading_Trade_PriceChangeData, rhs: Ru_Mts_Trading_Trade_PriceChangeData) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._subscriptionID != rhs_storage._subscriptionID {return false}
        if _storage._originalCurrencyPrice != rhs_storage._originalCurrencyPrice {return false}
        if _storage._targetCurrencyPrice != rhs_storage._targetCurrencyPrice {return false}
        if _storage._exchangeRate != rhs_storage._exchangeRate {return false}
        if _storage._lots != rhs_storage._lots {return false}
        if _storage._commission != rhs_storage._commission {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ru_Mts_Trading_Trade_HideRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HideRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "orderIds"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedUInt64Field(value: &self.orderIds)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.orderIds.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.orderIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ru_Mts_Trading_Trade_HideRequest, rhs: Ru_Mts_Trading_Trade_HideRequest) -> Bool {
    if lhs.orderIds != rhs.orderIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ru_Mts_Trading_Trade_HideResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HideResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ru_Mts_Trading_Trade_HideResponse, rhs: Ru_Mts_Trading_Trade_HideResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ru_Mts_Trading_Trade_WatchRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WatchRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "quantity"),
    3: .same(proto: "securityName"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.type)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.quantity)
      case 3: try decoder.decodeSingularStringField(value: &self.securityName)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .buy {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if self.quantity != 0 {
      try visitor.visitSingularUInt32Field(value: self.quantity, fieldNumber: 2)
    }
    if !self.securityName.isEmpty {
      try visitor.visitSingularStringField(value: self.securityName, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ru_Mts_Trading_Trade_WatchRequest, rhs: Ru_Mts_Trading_Trade_WatchRequest) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.quantity != rhs.quantity {return false}
    if lhs.securityName != rhs.securityName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ru_Mts_Trading_Trade_WatchPrice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WatchPrice"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "securityName"),
    3: .same(proto: "doublePrice"),
    4: .same(proto: "quantity"),
    5: .same(proto: "price"),
    6: .same(proto: "bid"),
    7: .same(proto: "ask"),
  ]

  fileprivate class _StorageClass {
    var _type: Ru_Mts_Trading_Trade_OperationType = .buy
    var _securityName: String = String()
    var _doublePrice: Double = 0
    var _quantity: UInt64 = 0
    var _price: Ru_Mts_Trading_Trade_Price? = nil
    var _bid: Ru_Mts_Trading_Trade_Price? = nil
    var _ask: Ru_Mts_Trading_Trade_Price? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _securityName = source._securityName
      _doublePrice = source._doublePrice
      _quantity = source._quantity
      _price = source._price
      _bid = source._bid
      _ask = source._ask
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._type)
        case 2: try decoder.decodeSingularStringField(value: &_storage._securityName)
        case 3: try decoder.decodeSingularDoubleField(value: &_storage._doublePrice)
        case 4: try decoder.decodeSingularUInt64Field(value: &_storage._quantity)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._price)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._bid)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._ask)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._type != .buy {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 1)
      }
      if !_storage._securityName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._securityName, fieldNumber: 2)
      }
      if _storage._doublePrice != 0 {
        try visitor.visitSingularDoubleField(value: _storage._doublePrice, fieldNumber: 3)
      }
      if _storage._quantity != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._quantity, fieldNumber: 4)
      }
      if let v = _storage._price {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._bid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._ask {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ru_Mts_Trading_Trade_WatchPrice, rhs: Ru_Mts_Trading_Trade_WatchPrice) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._securityName != rhs_storage._securityName {return false}
        if _storage._doublePrice != rhs_storage._doublePrice {return false}
        if _storage._quantity != rhs_storage._quantity {return false}
        if _storage._price != rhs_storage._price {return false}
        if _storage._bid != rhs_storage._bid {return false}
        if _storage._ask != rhs_storage._ask {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ru_Mts_Trading_Trade_Price: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Price"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "price"),
    2: .same(proto: "scale"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.price)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.scale)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.price != 0 {
      try visitor.visitSingularUInt64Field(value: self.price, fieldNumber: 1)
    }
    if self.scale != 0 {
      try visitor.visitSingularUInt64Field(value: self.scale, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ru_Mts_Trading_Trade_Price, rhs: Ru_Mts_Trading_Trade_Price) -> Bool {
    if lhs.price != rhs.price {return false}
    if lhs.scale != rhs.scale {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ru_Mts_Trading_Trade_TradingOperation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TradingOperation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "quantity"),
    3: .same(proto: "securityName"),
    4: .same(proto: "orderId"),
    5: .same(proto: "localId"),
    6: .same(proto: "price"),
    7: .same(proto: "priceValue"),
  ]

  fileprivate class _StorageClass {
    var _type: Ru_Mts_Trading_Trade_OperationType = .buy
    var _quantity: UInt32 = 0
    var _securityName: String = String()
    var _orderID: UInt64 = 0
    var _localID: UInt64 = 0
    var _price: Double = 0
    var _priceValue: Ru_Mts_Trading_Trade_Price? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _quantity = source._quantity
      _securityName = source._securityName
      _orderID = source._orderID
      _localID = source._localID
      _price = source._price
      _priceValue = source._priceValue
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._type)
        case 2: try decoder.decodeSingularUInt32Field(value: &_storage._quantity)
        case 3: try decoder.decodeSingularStringField(value: &_storage._securityName)
        case 4: try decoder.decodeSingularUInt64Field(value: &_storage._orderID)
        case 5: try decoder.decodeSingularUInt64Field(value: &_storage._localID)
        case 6: try decoder.decodeSingularDoubleField(value: &_storage._price)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._priceValue)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._type != .buy {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 1)
      }
      if _storage._quantity != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._quantity, fieldNumber: 2)
      }
      if !_storage._securityName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._securityName, fieldNumber: 3)
      }
      if _storage._orderID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._orderID, fieldNumber: 4)
      }
      if _storage._localID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._localID, fieldNumber: 5)
      }
      if _storage._price != 0 {
        try visitor.visitSingularDoubleField(value: _storage._price, fieldNumber: 6)
      }
      if let v = _storage._priceValue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ru_Mts_Trading_Trade_TradingOperation, rhs: Ru_Mts_Trading_Trade_TradingOperation) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._quantity != rhs_storage._quantity {return false}
        if _storage._securityName != rhs_storage._securityName {return false}
        if _storage._orderID != rhs_storage._orderID {return false}
        if _storage._localID != rhs_storage._localID {return false}
        if _storage._price != rhs_storage._price {return false}
        if _storage._priceValue != rhs_storage._priceValue {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ru_Mts_Trading_Trade_Order: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Order"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "orderId"),
    2: .same(proto: "localId"),
    3: .same(proto: "type"),
    4: .same(proto: "securityName"),
    5: .same(proto: "price"),
    6: .same(proto: "status"),
    7: .same(proto: "realPrice"),
    8: .same(proto: "lots"),
    9: .same(proto: "message"),
    10: .same(proto: "executedLots"),
    11: .same(proto: "hidden"),
  ]

  fileprivate class _StorageClass {
    var _orderID: UInt64 = 0
    var _localID: UInt64 = 0
    var _type: Ru_Mts_Trading_Trade_OperationType = .buy
    var _securityName: String = String()
    var _price: Double = 0
    var _status: Ru_Mts_Trading_Trade_OrderStatus = .pending
    var _realPrice: Ru_Mts_Trading_Trade_Price? = nil
    var _lots: UInt64 = 0
    var _message: String = String()
    var _executedLots: UInt64 = 0
    var _hidden: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _orderID = source._orderID
      _localID = source._localID
      _type = source._type
      _securityName = source._securityName
      _price = source._price
      _status = source._status
      _realPrice = source._realPrice
      _lots = source._lots
      _message = source._message
      _executedLots = source._executedLots
      _hidden = source._hidden
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt64Field(value: &_storage._orderID)
        case 2: try decoder.decodeSingularUInt64Field(value: &_storage._localID)
        case 3: try decoder.decodeSingularEnumField(value: &_storage._type)
        case 4: try decoder.decodeSingularStringField(value: &_storage._securityName)
        case 5: try decoder.decodeSingularDoubleField(value: &_storage._price)
        case 6: try decoder.decodeSingularEnumField(value: &_storage._status)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._realPrice)
        case 8: try decoder.decodeSingularUInt64Field(value: &_storage._lots)
        case 9: try decoder.decodeSingularStringField(value: &_storage._message)
        case 10: try decoder.decodeSingularUInt64Field(value: &_storage._executedLots)
        case 11: try decoder.decodeSingularBoolField(value: &_storage._hidden)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._orderID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._orderID, fieldNumber: 1)
      }
      if _storage._localID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._localID, fieldNumber: 2)
      }
      if _storage._type != .buy {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 3)
      }
      if !_storage._securityName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._securityName, fieldNumber: 4)
      }
      if _storage._price != 0 {
        try visitor.visitSingularDoubleField(value: _storage._price, fieldNumber: 5)
      }
      if _storage._status != .pending {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 6)
      }
      if let v = _storage._realPrice {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if _storage._lots != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._lots, fieldNumber: 8)
      }
      if !_storage._message.isEmpty {
        try visitor.visitSingularStringField(value: _storage._message, fieldNumber: 9)
      }
      if _storage._executedLots != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._executedLots, fieldNumber: 10)
      }
      if _storage._hidden != false {
        try visitor.visitSingularBoolField(value: _storage._hidden, fieldNumber: 11)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ru_Mts_Trading_Trade_Order, rhs: Ru_Mts_Trading_Trade_Order) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._orderID != rhs_storage._orderID {return false}
        if _storage._localID != rhs_storage._localID {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._securityName != rhs_storage._securityName {return false}
        if _storage._price != rhs_storage._price {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._realPrice != rhs_storage._realPrice {return false}
        if _storage._lots != rhs_storage._lots {return false}
        if _storage._message != rhs_storage._message {return false}
        if _storage._executedLots != rhs_storage._executedLots {return false}
        if _storage._hidden != rhs_storage._hidden {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: instruments-v2-common.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Ru_Mts_Trading_Grpc_Pub_Instruments_V2_Instrument {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var instrumentID: String {
    get {return _storage._instrumentID}
    set {_uniqueStorage()._instrumentID = newValue}
  }

  ///характеризует биржу, на которой торгуется инструмент
  var classCode: String {
    get {return _storage._classCode}
    set {_uniqueStorage()._classCode = newValue}
  }

  ///обобщенный тип инструмента(акция, облигация, ETF, валюта)
  var type: GrpcInstrumentCommonType {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  var isin: String {
    get {return _storage._isin}
    set {_uniqueStorage()._isin = newValue}
  }

  ///не уникальный ключ, видимый пользователю
  var ticker: String {
    get {return _storage._ticker}
    set {_uniqueStorage()._ticker = newValue}
  }

  ///название
  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  ///подробное описание
  var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  ///размер лота
  var lotSize: UInt32 {
    get {return _storage._lotSize}
    set {_uniqueStorage()._lotSize = newValue}
  }

  ///номинал в валюте
  var faceValue: GrpcStringDecimal {
    get {return _storage._faceValue ?? GrpcStringDecimal()}
    set {_uniqueStorage()._faceValue = newValue}
  }
  /// Returns true if `faceValue` has been explicitly set.
  var hasFaceValue: Bool {return _storage._faceValue != nil}
  /// Clears the value of `faceValue`. Subsequent reads from it will return its default value.
  mutating func clearFaceValue() {_uniqueStorage()._faceValue = nil}

  ///дата погашения
  var maturityDate: GrpcOptionalDate {
    get {return _storage._maturityDate ?? GrpcOptionalDate()}
    set {_uniqueStorage()._maturityDate = newValue}
  }
  /// Returns true if `maturityDate` has been explicitly set.
  var hasMaturityDate: Bool {return _storage._maturityDate != nil}
  /// Clears the value of `maturityDate`. Subsequent reads from it will return its default value.
  mutating func clearMaturityDate() {_uniqueStorage()._maturityDate = nil}

  ///валюта
  var currency: GrpcCurrency {
    get {return _storage._currency ?? GrpcCurrency()}
    set {_uniqueStorage()._currency = newValue}
  }
  /// Returns true if `currency` has been explicitly set.
  var hasCurrency: Bool {return _storage._currency != nil}
  /// Clears the value of `currency`. Subsequent reads from it will return its default value.
  mutating func clearCurrency() {_uniqueStorage()._currency = nil}

  ///минимальный шаг изменения цены при выставлении заявки
  var minStep: GrpcStringDecimal {
    get {return _storage._minStep ?? GrpcStringDecimal()}
    set {_uniqueStorage()._minStep = newValue}
  }
  /// Returns true if `minStep` has been explicitly set.
  var hasMinStep: Bool {return _storage._minStep != nil}
  /// Clears the value of `minStep`. Subsequent reads from it will return its default value.
  mutating func clearMinStep() {_uniqueStorage()._minStep = nil}

  ///количество знаков после запятой в цене
  var decimals: Int32 {
    get {return _storage._decimals}
    set {_uniqueStorage()._decimals = newValue}
  }

  ///ставка купона [облигации]
  var coupon: GrpcStringDecimal {
    get {return _storage._coupon ?? GrpcStringDecimal()}
    set {_uniqueStorage()._coupon = newValue}
  }
  /// Returns true if `coupon` has been explicitly set.
  var hasCoupon: Bool {return _storage._coupon != nil}
  /// Clears the value of `coupon`. Subsequent reads from it will return its default value.
  mutating func clearCoupon() {_uniqueStorage()._coupon = nil}

  ///период выплат купона [облигации]
  var couponPeriod: UInt32 {
    get {return _storage._couponPeriod}
    set {_uniqueStorage()._couponPeriod = newValue}
  }

  ///дата выплаты следующего купона [облигации]
  var nextCoupon: GrpcOptionalDate {
    get {return _storage._nextCoupon ?? GrpcOptionalDate()}
    set {_uniqueStorage()._nextCoupon = newValue}
  }
  /// Returns true if `nextCoupon` has been explicitly set.
  var hasNextCoupon: Bool {return _storage._nextCoupon != nil}
  /// Clears the value of `nextCoupon`. Subsequent reads from it will return its default value.
  mutating func clearNextCoupon() {_uniqueStorage()._nextCoupon = nil}

  ///НКД [облигации]
  var accruedInterest: GrpcStringDecimal {
    get {return _storage._accruedInterest ?? GrpcStringDecimal()}
    set {_uniqueStorage()._accruedInterest = newValue}
  }
  /// Returns true if `accruedInterest` has been explicitly set.
  var hasAccruedInterest: Bool {return _storage._accruedInterest != nil}
  /// Clears the value of `accruedInterest`. Subsequent reads from it will return its default value.
  mutating func clearAccruedInterest() {_uniqueStorage()._accruedInterest = nil}

  var state: Ru_Mts_Trading_Grpc_Pub_Instruments_V2_Instrument.InstrumentState {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  var bookBuilding: Ru_Mts_Trading_Grpc_Pub_Instruments_V2_BookBuilding {
    get {return _storage._bookBuilding ?? Ru_Mts_Trading_Grpc_Pub_Instruments_V2_BookBuilding()}
    set {_uniqueStorage()._bookBuilding = newValue}
  }
  /// Returns true if `bookBuilding` has been explicitly set.
  var hasBookBuilding: Bool {return _storage._bookBuilding != nil}
  /// Clears the value of `bookBuilding`. Subsequent reads from it will return its default value.
  mutating func clearBookBuilding() {_uniqueStorage()._bookBuilding = nil}

  ///идентификатор расписания торгов инструмента
  var scheduleID: String {
    get {return _storage._scheduleID}
    set {_uniqueStorage()._scheduleID = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum InstrumentState: SwiftProtobuf.Enum {
    typealias RawValue = Int

    ///бумага не активна, используется как дефолтное значение при добавлении новых значений статусов
    case notActive // = 0

    ///бумага активна (торгуется на бирже)
    case active // = 1

    ///бумага погашена (только для облиг)
    case maturity // = 2

    ///бумага заблокирована для торгов
    case blocked // = 3

    ///прием заявок еще не начат
    case preBookBuilding // = 4

    ///идет прием заявок
    case bookBuilding // = 5

    ///идет исполнение заявок (размещение)
    case allocating // = 6
    case UNRECOGNIZED(Int)

    init() {
      self = .notActive
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .notActive
      case 1: self = .active
      case 2: self = .maturity
      case 3: self = .blocked
      case 4: self = .preBookBuilding
      case 5: self = .bookBuilding
      case 6: self = .allocating
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .notActive: return 0
      case .active: return 1
      case .maturity: return 2
      case .blocked: return 3
      case .preBookBuilding: return 4
      case .bookBuilding: return 5
      case .allocating: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Ru_Mts_Trading_Grpc_Pub_Instruments_V2_Instrument.InstrumentState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Ru_Mts_Trading_Grpc_Pub_Instruments_V2_Instrument.InstrumentState] = [
    .notActive,
    .active,
    .maturity,
    .blocked,
    .preBookBuilding,
    .bookBuilding,
    .allocating,
  ]
}

#endif  // swift(>=4.2)

struct Ru_Mts_Trading_Grpc_Pub_Instruments_V2_BookBuilding {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: OneOf_Type? {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  var couponRangeType: Ru_Mts_Trading_Grpc_Pub_Instruments_V2_BookBuilding.TypeCouponRange {
    get {
      if case .couponRangeType(let v)? = _storage._type {return v}
      return Ru_Mts_Trading_Grpc_Pub_Instruments_V2_BookBuilding.TypeCouponRange()
    }
    set {_uniqueStorage()._type = .couponRangeType(newValue)}
  }

  var couponFixType: Ru_Mts_Trading_Grpc_Pub_Instruments_V2_BookBuilding.TypeCouponFix {
    get {
      if case .couponFixType(let v)? = _storage._type {return v}
      return Ru_Mts_Trading_Grpc_Pub_Instruments_V2_BookBuilding.TypeCouponFix()
    }
    set {_uniqueStorage()._type = .couponFixType(newValue)}
  }

  var minLotCount: Int32 {
    get {return _storage._minLotCount}
    set {_uniqueStorage()._minLotCount = newValue}
  }

  var maxLotCount: Int32 {
    get {return _storage._maxLotCount}
    set {_uniqueStorage()._maxLotCount = newValue}
  }

  ///Старт приёма заявок (дата и время в UTC)
  var bookBuildingStart: GrpcDateTime {
    get {return _storage._bookBuildingStart ?? GrpcDateTime()}
    set {_uniqueStorage()._bookBuildingStart = newValue}
  }
  /// Returns true if `bookBuildingStart` has been explicitly set.
  var hasBookBuildingStart: Bool {return _storage._bookBuildingStart != nil}
  /// Clears the value of `bookBuildingStart`. Subsequent reads from it will return its default value.
  mutating func clearBookBuildingStart() {_uniqueStorage()._bookBuildingStart = nil}

  ///Окончание приёма заявок (дата и время в UTC)
  var bookBuildingFinish: GrpcDateTime {
    get {return _storage._bookBuildingFinish ?? GrpcDateTime()}
    set {_uniqueStorage()._bookBuildingFinish = newValue}
  }
  /// Returns true if `bookBuildingFinish` has been explicitly set.
  var hasBookBuildingFinish: Bool {return _storage._bookBuildingFinish != nil}
  /// Clears the value of `bookBuildingFinish`. Subsequent reads from it will return its default value.
  mutating func clearBookBuildingFinish() {_uniqueStorage()._bookBuildingFinish = nil}

  ///размер комиссии в процентах
  var feePercent: GrpcStringDecimal {
    get {return _storage._feePercent ?? GrpcStringDecimal()}
    set {_uniqueStorage()._feePercent = newValue}
  }
  /// Returns true if `feePercent` has been explicitly set.
  var hasFeePercent: Bool {return _storage._feePercent != nil}
  /// Clears the value of `feePercent`. Subsequent reads from it will return its default value.
  mutating func clearFeePercent() {_uniqueStorage()._feePercent = nil}

  ///ожидаемая доходность в % годовых
  var yieldPerAnnum: OneOf_YieldPerAnnum? {
    get {return _storage._yieldPerAnnum}
    set {_uniqueStorage()._yieldPerAnnum = newValue}
  }

  ///точное значение (например, для фиксированного купона)
  var yieldPerAnnumValue: GrpcStringDecimal {
    get {
      if case .yieldPerAnnumValue(let v)? = _storage._yieldPerAnnum {return v}
      return GrpcStringDecimal()
    }
    set {_uniqueStorage()._yieldPerAnnum = .yieldPerAnnumValue(newValue)}
  }

  ///диапазон (например, для диапазона купона)
  var yieldPerAnnumRange: Ru_Mts_Trading_Grpc_Pub_Instruments_V2_BookBuilding.YieldPerAnnumRange {
    get {
      if case .yieldPerAnnumRange(let v)? = _storage._yieldPerAnnum {return v}
      return Ru_Mts_Trading_Grpc_Pub_Instruments_V2_BookBuilding.YieldPerAnnumRange()
    }
    set {_uniqueStorage()._yieldPerAnnum = .yieldPerAnnumRange(newValue)}
  }

  var price: GrpcStringDecimal {
    get {return _storage._price ?? GrpcStringDecimal()}
    set {_uniqueStorage()._price = newValue}
  }
  /// Returns true if `price` has been explicitly set.
  var hasPrice: Bool {return _storage._price != nil}
  /// Clears the value of `price`. Subsequent reads from it will return its default value.
  mutating func clearPrice() {_uniqueStorage()._price = nil}

  var contraBroker: String {
    get {return _storage._contraBroker}
    set {_uniqueStorage()._contraBroker = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Type: Equatable {
    case couponRangeType(Ru_Mts_Trading_Grpc_Pub_Instruments_V2_BookBuilding.TypeCouponRange)
    case couponFixType(Ru_Mts_Trading_Grpc_Pub_Instruments_V2_BookBuilding.TypeCouponFix)

  #if !swift(>=4.1)
    static func ==(lhs: Ru_Mts_Trading_Grpc_Pub_Instruments_V2_BookBuilding.OneOf_Type, rhs: Ru_Mts_Trading_Grpc_Pub_Instruments_V2_BookBuilding.OneOf_Type) -> Bool {
      switch (lhs, rhs) {
      case (.couponRangeType(let l), .couponRangeType(let r)): return l == r
      case (.couponFixType(let l), .couponFixType(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  ///ожидаемая доходность в % годовых
  enum OneOf_YieldPerAnnum: Equatable {
    ///точное значение (например, для фиксированного купона)
    case yieldPerAnnumValue(GrpcStringDecimal)
    ///диапазон (например, для диапазона купона)
    case yieldPerAnnumRange(Ru_Mts_Trading_Grpc_Pub_Instruments_V2_BookBuilding.YieldPerAnnumRange)

  #if !swift(>=4.1)
    static func ==(lhs: Ru_Mts_Trading_Grpc_Pub_Instruments_V2_BookBuilding.OneOf_YieldPerAnnum, rhs: Ru_Mts_Trading_Grpc_Pub_Instruments_V2_BookBuilding.OneOf_YieldPerAnnum) -> Bool {
      switch (lhs, rhs) {
      case (.yieldPerAnnumValue(let l), .yieldPerAnnumValue(let r)): return l == r
      case (.yieldPerAnnumRange(let l), .yieldPerAnnumRange(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  struct TypeCouponRange {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var couponMin: GrpcStringDecimal {
      get {return _storage._couponMin ?? GrpcStringDecimal()}
      set {_uniqueStorage()._couponMin = newValue}
    }
    /// Returns true if `couponMin` has been explicitly set.
    var hasCouponMin: Bool {return _storage._couponMin != nil}
    /// Clears the value of `couponMin`. Subsequent reads from it will return its default value.
    mutating func clearCouponMin() {_uniqueStorage()._couponMin = nil}

    var couponMax: GrpcStringDecimal {
      get {return _storage._couponMax ?? GrpcStringDecimal()}
      set {_uniqueStorage()._couponMax = newValue}
    }
    /// Returns true if `couponMax` has been explicitly set.
    var hasCouponMax: Bool {return _storage._couponMax != nil}
    /// Clears the value of `couponMax`. Subsequent reads from it will return its default value.
    mutating func clearCouponMax() {_uniqueStorage()._couponMax = nil}

    ///предыдущее значение, если оно было изменено
    var previousCouponMin: GrpcOptionalStringDecimal {
      get {return _storage._previousCouponMin ?? GrpcOptionalStringDecimal()}
      set {_uniqueStorage()._previousCouponMin = newValue}
    }
    /// Returns true if `previousCouponMin` has been explicitly set.
    var hasPreviousCouponMin: Bool {return _storage._previousCouponMin != nil}
    /// Clears the value of `previousCouponMin`. Subsequent reads from it will return its default value.
    mutating func clearPreviousCouponMin() {_uniqueStorage()._previousCouponMin = nil}

    var previousCouponMax: GrpcOptionalStringDecimal {
      get {return _storage._previousCouponMax ?? GrpcOptionalStringDecimal()}
      set {_uniqueStorage()._previousCouponMax = newValue}
    }
    /// Returns true if `previousCouponMax` has been explicitly set.
    var hasPreviousCouponMax: Bool {return _storage._previousCouponMax != nil}
    /// Clears the value of `previousCouponMax`. Subsequent reads from it will return its default value.
    mutating func clearPreviousCouponMax() {_uniqueStorage()._previousCouponMax = nil}

    var couponStep: GrpcStringDecimal {
      get {return _storage._couponStep ?? GrpcStringDecimal()}
      set {_uniqueStorage()._couponStep = newValue}
    }
    /// Returns true if `couponStep` has been explicitly set.
    var hasCouponStep: Bool {return _storage._couponStep != nil}
    /// Clears the value of `couponStep`. Subsequent reads from it will return its default value.
    mutating func clearCouponStep() {_uniqueStorage()._couponStep = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  struct TypeCouponFix {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var coupon: GrpcStringDecimal {
      get {return _storage._coupon ?? GrpcStringDecimal()}
      set {_uniqueStorage()._coupon = newValue}
    }
    /// Returns true if `coupon` has been explicitly set.
    var hasCoupon: Bool {return _storage._coupon != nil}
    /// Clears the value of `coupon`. Subsequent reads from it will return its default value.
    mutating func clearCoupon() {_uniqueStorage()._coupon = nil}

    var previousCoupon: GrpcOptionalStringDecimal {
      get {return _storage._previousCoupon ?? GrpcOptionalStringDecimal()}
      set {_uniqueStorage()._previousCoupon = newValue}
    }
    /// Returns true if `previousCoupon` has been explicitly set.
    var hasPreviousCoupon: Bool {return _storage._previousCoupon != nil}
    /// Clears the value of `previousCoupon`. Subsequent reads from it will return its default value.
    mutating func clearPreviousCoupon() {_uniqueStorage()._previousCoupon = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  struct YieldPerAnnumRange {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var min: GrpcStringDecimal {
      get {return _storage._min ?? GrpcStringDecimal()}
      set {_uniqueStorage()._min = newValue}
    }
    /// Returns true if `min` has been explicitly set.
    var hasMin: Bool {return _storage._min != nil}
    /// Clears the value of `min`. Subsequent reads from it will return its default value.
    mutating func clearMin() {_uniqueStorage()._min = nil}

    var max: GrpcStringDecimal {
      get {return _storage._max ?? GrpcStringDecimal()}
      set {_uniqueStorage()._max = newValue}
    }
    /// Returns true if `max` has been explicitly set.
    var hasMax: Bool {return _storage._max != nil}
    /// Clears the value of `max`. Subsequent reads from it will return its default value.
    mutating func clearMax() {_uniqueStorage()._max = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Ru_Mts_Trading_Grpc_Pub_Instruments_V2_InstrumentList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var instrument: [Ru_Mts_Trading_Grpc_Pub_Instruments_V2_Instrument] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "ru.mts.trading.grpc.pub.instruments.v2"

extension Ru_Mts_Trading_Grpc_Pub_Instruments_V2_Instrument: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Instrument"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "instrumentId"),
    2: .same(proto: "classCode"),
    3: .same(proto: "type"),
    4: .same(proto: "isin"),
    5: .same(proto: "ticker"),
    6: .same(proto: "name"),
    7: .same(proto: "description"),
    8: .same(proto: "lotSize"),
    9: .same(proto: "faceValue"),
    10: .same(proto: "maturityDate"),
    11: .same(proto: "currency"),
    12: .same(proto: "minStep"),
    13: .same(proto: "decimals"),
    14: .same(proto: "coupon"),
    15: .same(proto: "couponPeriod"),
    16: .same(proto: "nextCoupon"),
    17: .same(proto: "accruedInterest"),
    18: .same(proto: "state"),
    19: .same(proto: "bookBuilding"),
    20: .same(proto: "scheduleId"),
  ]

  fileprivate class _StorageClass {
    var _instrumentID: String = String()
    var _classCode: String = String()
    var _type: GrpcInstrumentCommonType = .other
    var _isin: String = String()
    var _ticker: String = String()
    var _name: String = String()
    var _description_p: String = String()
    var _lotSize: UInt32 = 0
    var _faceValue: GrpcStringDecimal? = nil
    var _maturityDate: GrpcOptionalDate? = nil
    var _currency: GrpcCurrency? = nil
    var _minStep: GrpcStringDecimal? = nil
    var _decimals: Int32 = 0
    var _coupon: GrpcStringDecimal? = nil
    var _couponPeriod: UInt32 = 0
    var _nextCoupon: GrpcOptionalDate? = nil
    var _accruedInterest: GrpcStringDecimal? = nil
    var _state: Ru_Mts_Trading_Grpc_Pub_Instruments_V2_Instrument.InstrumentState = .notActive
    var _bookBuilding: Ru_Mts_Trading_Grpc_Pub_Instruments_V2_BookBuilding? = nil
    var _scheduleID: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _instrumentID = source._instrumentID
      _classCode = source._classCode
      _type = source._type
      _isin = source._isin
      _ticker = source._ticker
      _name = source._name
      _description_p = source._description_p
      _lotSize = source._lotSize
      _faceValue = source._faceValue
      _maturityDate = source._maturityDate
      _currency = source._currency
      _minStep = source._minStep
      _decimals = source._decimals
      _coupon = source._coupon
      _couponPeriod = source._couponPeriod
      _nextCoupon = source._nextCoupon
      _accruedInterest = source._accruedInterest
      _state = source._state
      _bookBuilding = source._bookBuilding
      _scheduleID = source._scheduleID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._instrumentID)
        case 2: try decoder.decodeSingularStringField(value: &_storage._classCode)
        case 3: try decoder.decodeSingularEnumField(value: &_storage._type)
        case 4: try decoder.decodeSingularStringField(value: &_storage._isin)
        case 5: try decoder.decodeSingularStringField(value: &_storage._ticker)
        case 6: try decoder.decodeSingularStringField(value: &_storage._name)
        case 7: try decoder.decodeSingularStringField(value: &_storage._description_p)
        case 8: try decoder.decodeSingularUInt32Field(value: &_storage._lotSize)
        case 9: try decoder.decodeSingularMessageField(value: &_storage._faceValue)
        case 10: try decoder.decodeSingularMessageField(value: &_storage._maturityDate)
        case 11: try decoder.decodeSingularMessageField(value: &_storage._currency)
        case 12: try decoder.decodeSingularMessageField(value: &_storage._minStep)
        case 13: try decoder.decodeSingularInt32Field(value: &_storage._decimals)
        case 14: try decoder.decodeSingularMessageField(value: &_storage._coupon)
        case 15: try decoder.decodeSingularUInt32Field(value: &_storage._couponPeriod)
        case 16: try decoder.decodeSingularMessageField(value: &_storage._nextCoupon)
        case 17: try decoder.decodeSingularMessageField(value: &_storage._accruedInterest)
        case 18: try decoder.decodeSingularEnumField(value: &_storage._state)
        case 19: try decoder.decodeSingularMessageField(value: &_storage._bookBuilding)
        case 20: try decoder.decodeSingularStringField(value: &_storage._scheduleID)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._instrumentID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._instrumentID, fieldNumber: 1)
      }
      if !_storage._classCode.isEmpty {
        try visitor.visitSingularStringField(value: _storage._classCode, fieldNumber: 2)
      }
      if _storage._type != .other {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 3)
      }
      if !_storage._isin.isEmpty {
        try visitor.visitSingularStringField(value: _storage._isin, fieldNumber: 4)
      }
      if !_storage._ticker.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ticker, fieldNumber: 5)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 6)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 7)
      }
      if _storage._lotSize != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._lotSize, fieldNumber: 8)
      }
      if let v = _storage._faceValue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if let v = _storage._maturityDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if let v = _storage._currency {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
      if let v = _storage._minStep {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }
      if _storage._decimals != 0 {
        try visitor.visitSingularInt32Field(value: _storage._decimals, fieldNumber: 13)
      }
      if let v = _storage._coupon {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }
      if _storage._couponPeriod != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._couponPeriod, fieldNumber: 15)
      }
      if let v = _storage._nextCoupon {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }
      if let v = _storage._accruedInterest {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }
      if _storage._state != .notActive {
        try visitor.visitSingularEnumField(value: _storage._state, fieldNumber: 18)
      }
      if let v = _storage._bookBuilding {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      }
      if !_storage._scheduleID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._scheduleID, fieldNumber: 20)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ru_Mts_Trading_Grpc_Pub_Instruments_V2_Instrument, rhs: Ru_Mts_Trading_Grpc_Pub_Instruments_V2_Instrument) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._instrumentID != rhs_storage._instrumentID {return false}
        if _storage._classCode != rhs_storage._classCode {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._isin != rhs_storage._isin {return false}
        if _storage._ticker != rhs_storage._ticker {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._lotSize != rhs_storage._lotSize {return false}
        if _storage._faceValue != rhs_storage._faceValue {return false}
        if _storage._maturityDate != rhs_storage._maturityDate {return false}
        if _storage._currency != rhs_storage._currency {return false}
        if _storage._minStep != rhs_storage._minStep {return false}
        if _storage._decimals != rhs_storage._decimals {return false}
        if _storage._coupon != rhs_storage._coupon {return false}
        if _storage._couponPeriod != rhs_storage._couponPeriod {return false}
        if _storage._nextCoupon != rhs_storage._nextCoupon {return false}
        if _storage._accruedInterest != rhs_storage._accruedInterest {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._bookBuilding != rhs_storage._bookBuilding {return false}
        if _storage._scheduleID != rhs_storage._scheduleID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ru_Mts_Trading_Grpc_Pub_Instruments_V2_Instrument.InstrumentState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NOT_ACTIVE"),
    1: .same(proto: "ACTIVE"),
    2: .same(proto: "MATURITY"),
    3: .same(proto: "BLOCKED"),
    4: .same(proto: "PRE_BOOK_BUILDING"),
    5: .same(proto: "BOOK_BUILDING"),
    6: .same(proto: "ALLOCATING"),
  ]
}

extension Ru_Mts_Trading_Grpc_Pub_Instruments_V2_BookBuilding: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BookBuilding"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "couponRangeType"),
    2: .same(proto: "couponFixType"),
    101: .same(proto: "minLotCount"),
    102: .same(proto: "maxLotCount"),
    103: .same(proto: "bookBuildingStart"),
    104: .same(proto: "bookBuildingFinish"),
    105: .same(proto: "feePercent"),
    106: .same(proto: "yieldPerAnnumValue"),
    107: .same(proto: "yieldPerAnnumRange"),
    108: .same(proto: "price"),
    109: .same(proto: "contraBroker"),
  ]

  fileprivate class _StorageClass {
    var _type: Ru_Mts_Trading_Grpc_Pub_Instruments_V2_BookBuilding.OneOf_Type?
    var _minLotCount: Int32 = 0
    var _maxLotCount: Int32 = 0
    var _bookBuildingStart: GrpcDateTime? = nil
    var _bookBuildingFinish: GrpcDateTime? = nil
    var _feePercent: GrpcStringDecimal? = nil
    var _yieldPerAnnum: Ru_Mts_Trading_Grpc_Pub_Instruments_V2_BookBuilding.OneOf_YieldPerAnnum?
    var _price: GrpcStringDecimal? = nil
    var _contraBroker: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _minLotCount = source._minLotCount
      _maxLotCount = source._maxLotCount
      _bookBuildingStart = source._bookBuildingStart
      _bookBuildingFinish = source._bookBuildingFinish
      _feePercent = source._feePercent
      _yieldPerAnnum = source._yieldPerAnnum
      _price = source._price
      _contraBroker = source._contraBroker
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Ru_Mts_Trading_Grpc_Pub_Instruments_V2_BookBuilding.TypeCouponRange?
          if let current = _storage._type {
            try decoder.handleConflictingOneOf()
            if case .couponRangeType(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._type = .couponRangeType(v)}
        case 2:
          var v: Ru_Mts_Trading_Grpc_Pub_Instruments_V2_BookBuilding.TypeCouponFix?
          if let current = _storage._type {
            try decoder.handleConflictingOneOf()
            if case .couponFixType(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._type = .couponFixType(v)}
        case 101: try decoder.decodeSingularInt32Field(value: &_storage._minLotCount)
        case 102: try decoder.decodeSingularInt32Field(value: &_storage._maxLotCount)
        case 103: try decoder.decodeSingularMessageField(value: &_storage._bookBuildingStart)
        case 104: try decoder.decodeSingularMessageField(value: &_storage._bookBuildingFinish)
        case 105: try decoder.decodeSingularMessageField(value: &_storage._feePercent)
        case 106:
          var v: GrpcStringDecimal?
          if let current = _storage._yieldPerAnnum {
            try decoder.handleConflictingOneOf()
            if case .yieldPerAnnumValue(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._yieldPerAnnum = .yieldPerAnnumValue(v)}
        case 107:
          var v: Ru_Mts_Trading_Grpc_Pub_Instruments_V2_BookBuilding.YieldPerAnnumRange?
          if let current = _storage._yieldPerAnnum {
            try decoder.handleConflictingOneOf()
            if case .yieldPerAnnumRange(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._yieldPerAnnum = .yieldPerAnnumRange(v)}
        case 108: try decoder.decodeSingularMessageField(value: &_storage._price)
        case 109: try decoder.decodeSingularStringField(value: &_storage._contraBroker)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._type {
      case .couponRangeType(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .couponFixType(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case nil: break
      }
      if _storage._minLotCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._minLotCount, fieldNumber: 101)
      }
      if _storage._maxLotCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._maxLotCount, fieldNumber: 102)
      }
      if let v = _storage._bookBuildingStart {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
      }
      if let v = _storage._bookBuildingFinish {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 104)
      }
      if let v = _storage._feePercent {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 105)
      }
      switch _storage._yieldPerAnnum {
      case .yieldPerAnnumValue(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 106)
      case .yieldPerAnnumRange(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 107)
      case nil: break
      }
      if let v = _storage._price {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 108)
      }
      if !_storage._contraBroker.isEmpty {
        try visitor.visitSingularStringField(value: _storage._contraBroker, fieldNumber: 109)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ru_Mts_Trading_Grpc_Pub_Instruments_V2_BookBuilding, rhs: Ru_Mts_Trading_Grpc_Pub_Instruments_V2_BookBuilding) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._minLotCount != rhs_storage._minLotCount {return false}
        if _storage._maxLotCount != rhs_storage._maxLotCount {return false}
        if _storage._bookBuildingStart != rhs_storage._bookBuildingStart {return false}
        if _storage._bookBuildingFinish != rhs_storage._bookBuildingFinish {return false}
        if _storage._feePercent != rhs_storage._feePercent {return false}
        if _storage._yieldPerAnnum != rhs_storage._yieldPerAnnum {return false}
        if _storage._price != rhs_storage._price {return false}
        if _storage._contraBroker != rhs_storage._contraBroker {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ru_Mts_Trading_Grpc_Pub_Instruments_V2_BookBuilding.TypeCouponRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Ru_Mts_Trading_Grpc_Pub_Instruments_V2_BookBuilding.protoMessageName + ".TypeCouponRange"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "couponMin"),
    2: .same(proto: "couponMax"),
    3: .same(proto: "previousCouponMin"),
    4: .same(proto: "previousCouponMax"),
    5: .same(proto: "couponStep"),
  ]

  fileprivate class _StorageClass {
    var _couponMin: GrpcStringDecimal? = nil
    var _couponMax: GrpcStringDecimal? = nil
    var _previousCouponMin: GrpcOptionalStringDecimal? = nil
    var _previousCouponMax: GrpcOptionalStringDecimal? = nil
    var _couponStep: GrpcStringDecimal? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _couponMin = source._couponMin
      _couponMax = source._couponMax
      _previousCouponMin = source._previousCouponMin
      _previousCouponMax = source._previousCouponMax
      _couponStep = source._couponStep
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._couponMin)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._couponMax)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._previousCouponMin)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._previousCouponMax)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._couponStep)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._couponMin {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._couponMax {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._previousCouponMin {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._previousCouponMax {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._couponStep {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ru_Mts_Trading_Grpc_Pub_Instruments_V2_BookBuilding.TypeCouponRange, rhs: Ru_Mts_Trading_Grpc_Pub_Instruments_V2_BookBuilding.TypeCouponRange) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._couponMin != rhs_storage._couponMin {return false}
        if _storage._couponMax != rhs_storage._couponMax {return false}
        if _storage._previousCouponMin != rhs_storage._previousCouponMin {return false}
        if _storage._previousCouponMax != rhs_storage._previousCouponMax {return false}
        if _storage._couponStep != rhs_storage._couponStep {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ru_Mts_Trading_Grpc_Pub_Instruments_V2_BookBuilding.TypeCouponFix: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Ru_Mts_Trading_Grpc_Pub_Instruments_V2_BookBuilding.protoMessageName + ".TypeCouponFix"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "coupon"),
    2: .same(proto: "previousCoupon"),
  ]

  fileprivate class _StorageClass {
    var _coupon: GrpcStringDecimal? = nil
    var _previousCoupon: GrpcOptionalStringDecimal? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _coupon = source._coupon
      _previousCoupon = source._previousCoupon
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._coupon)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._previousCoupon)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._coupon {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._previousCoupon {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ru_Mts_Trading_Grpc_Pub_Instruments_V2_BookBuilding.TypeCouponFix, rhs: Ru_Mts_Trading_Grpc_Pub_Instruments_V2_BookBuilding.TypeCouponFix) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._coupon != rhs_storage._coupon {return false}
        if _storage._previousCoupon != rhs_storage._previousCoupon {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ru_Mts_Trading_Grpc_Pub_Instruments_V2_BookBuilding.YieldPerAnnumRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Ru_Mts_Trading_Grpc_Pub_Instruments_V2_BookBuilding.protoMessageName + ".YieldPerAnnumRange"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "min"),
    2: .same(proto: "max"),
  ]

  fileprivate class _StorageClass {
    var _min: GrpcStringDecimal? = nil
    var _max: GrpcStringDecimal? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _min = source._min
      _max = source._max
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._min)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._max)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._min {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._max {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ru_Mts_Trading_Grpc_Pub_Instruments_V2_BookBuilding.YieldPerAnnumRange, rhs: Ru_Mts_Trading_Grpc_Pub_Instruments_V2_BookBuilding.YieldPerAnnumRange) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._min != rhs_storage._min {return false}
        if _storage._max != rhs_storage._max {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ru_Mts_Trading_Grpc_Pub_Instruments_V2_InstrumentList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InstrumentList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "instrument"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.instrument)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.instrument.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.instrument, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ru_Mts_Trading_Grpc_Pub_Instruments_V2_InstrumentList, rhs: Ru_Mts_Trading_Grpc_Pub_Instruments_V2_InstrumentList) -> Bool {
    if lhs.instrument != rhs.instrument {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
